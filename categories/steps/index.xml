<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>steps on pypyr</title><link>https://pypyr.io/categories/steps/</link><description>Recent content in steps on pypyr</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 12 Nov 2022 09:52:00 -0500</lastBuildDate><atom:link href="https://pypyr.io/categories/steps/index.xml" rel="self" type="application/rss+xml"/><item><title>pypyr.steps.switch</title><link>https://pypyr.io/docs/steps/switch/</link><pubDate>Wed, 19 Oct 2022 13:54:25 +0100</pubDate><guid>https://pypyr.io/docs/steps/switch/</guid><description>pypyr.steps.switch permalink conditional branching permalinkControl-of-flow statement that lets you conditionally select between execution branches depending on whether the controlling case expression evaluates to True.
You can conceptualize this as an IF-THEN-ELSE or IF-ELIF-ELSE style conditional branch. If you&amp;rsquo;re not branching between different execution paths, but instead just want to control whether an individual step runs, you can use the run or skip decorators instead.
# ./my-pipeline.yaml context_parser: pypyr.parser.string steps: - name: pypyr.</description></item><item><title>pypyr.steps.venv</title><link>https://pypyr.io/docs/steps/venv/</link><pubDate>Tue, 04 Oct 2022 15:27:43 +0100</pubDate><guid>https://pypyr.io/docs/steps/venv/</guid><description>pypyr.steps.venv permalinkCreate Python stdlib virtual environments (venv) from config without writing any script yourself. This is the equivalent of running $ python -m venv my-dir.
This step lets you create venvs from within your automation pipeline.
If you just want to create a bunch of venvs but you don&amp;rsquo;t want to write your own pipeline to do so, check out the built-in venv-create pipeline.
This steps creates multiple venvs in parallel concurrently, making for faster processing on what is usually a pretty slow process.</description></item><item><title>pypyr.steps.shells</title><link>https://pypyr.io/docs/steps/shells/</link><pubDate>Mon, 23 May 2022 08:35:53 +0100</pubDate><guid>https://pypyr.io/docs/steps/shells/</guid><description>pypyr.steps.shells permalink run shell statements concurrently permalinkRuns shell statements in parallel in the default shell. The default shell is usually /bin/sh on POSIX, and on Windows it&amp;rsquo;s cmd.exe.
Where the cmds step runs programs or executables, shells passes the commands through to the system shell. This means all your usual shell expressions are available, such as ~ expansions and your favorite bashisms.
If you just want to run parallel programs, scripts or executables with arguments, you do NOT need to use shells, you can use pypyr.</description></item><item><title>pypyr.steps.cmds</title><link>https://pypyr.io/docs/steps/cmds/</link><pubDate>Mon, 23 May 2022 08:35:40 +0100</pubDate><guid>https://pypyr.io/docs/steps/cmds/</guid><description>pypyr.steps.cmds permalink run programs concurrently permalinkRun programs, external scripts, applications or commands in parallel. This step launches executables as asynchronous subprocesses that run concurrently in parallel.
Step input can take two forms: simple syntax or expanded syntax. Simple syntax is just a list of strings. This will run the commands in parallel with the default options.
posix # simple syntax - name: pypyr.steps.cmds comment: copy 3 files concurrently in: cmds: - cp file1.</description></item><item><title>pypyr.steps.python</title><link>https://pypyr.io/docs/steps/python/</link><pubDate>Sat, 19 Feb 2022 16:04:49 +0000</pubDate><guid>https://pypyr.io/docs/steps/python/</guid><description>pypyr.steps.python permalinkGet the full path of the executable binary of the Python interpreter running the current pypyr session.
The step writes the absolute path as a string to the python key in context.
This means that wherever you would&amp;rsquo;ve invoked python or python3 as a subprocess, you can instead use {python}. This will replace the {python} token with the absolute path of the Python executable that is currently running pypyr.</description></item><item><title>pypyr.steps.configvars</title><link>https://pypyr.io/docs/steps/configvars/</link><pubDate>Sun, 13 Feb 2022 13:54:20 +0000</pubDate><guid>https://pypyr.io/docs/steps/configvars/</guid><description>pypyr.steps.configvars permalinkUse the configvars step to inject variables that you set in pyproject.toml or in the pypyr yaml config files into your pipeline. This allows you to get populate your pipeline variables dynamically from project configuration specific to your repo, or to use user or global settings in your pipeline.
configvars is a simple step that doesn&amp;rsquo;t take any inputs - it just looks for vars in the pypyr config files.</description></item><item><title>pypyr.steps.fileread</title><link>https://pypyr.io/docs/steps/fileread/</link><pubDate>Sun, 12 Dec 2021 15:02:21 +0100</pubDate><guid>https://pypyr.io/docs/steps/fileread/</guid><description>pypyr.steps.fileread permalink read file into context permalinkLoad a file into the the pypyr context.
fileread works like this:
- name: pypyr.steps.fileread comment: read file in into context in: fileRead: path: path/to/file.ext # path to file key: arb # save file contents to this context key binary: False # Optional. Default False. Set True to read file as bytes. encoding: utf-8 # Optional. Default None (platform default). If path is relative, it resolves relative to the current working directory.</description></item><item><title>pypyr.steps.filewrite</title><link>https://pypyr.io/docs/steps/filewrite/</link><pubDate>Sun, 12 Dec 2021 11:38:51 +0100</pubDate><guid>https://pypyr.io/docs/steps/filewrite/</guid><description>pypyr.steps.filewrite permalink create file from any context object permalinkFormat &amp;amp; write a payload to a file.
filewrite works like this:
- name: pypyr.steps.filewrite comment: write payload out to file at path. in: fileWrite: path: /path/to/output.ext # destination path payload: file content here # payload to write to path append: False # (optional) Default False to overwrite existing binary: False # (optional) Default False for text mode. True for bytes/binary. encoding: utf-8 # Optional.</description></item><item><title>pypyr.steps.filewritetoml</title><link>https://pypyr.io/docs/steps/filewritetoml/</link><pubDate>Sat, 11 Dec 2021 11:38:51 +0100</pubDate><guid>https://pypyr.io/docs/steps/filewritetoml/</guid><description>pypyr.steps.filewritetoml permalink create toml file from any context object permalinkFormat &amp;amp; write a payload to a toml file on disk. This is useful for generating toml files from your pipeline, such as when you want to create configuration files dynamically on the fly.
filewritetoml works like this:
- name: pypyr.steps.filewritetoml comment: write context payload out to toml in: fileWriteToml: path: /path/to/output.toml # destination file payload: # (optional) payload to write to path key1: value1 # output a string key2: value2 key3: 124 # output int key4: false # output bool table: mylist: - 1 - 2 myvalue: arb value This will generate the following toml to /path/to/output.</description></item><item><title>pypyr.steps.fetchtoml</title><link>https://pypyr.io/docs/steps/fetchtoml/</link><pubDate>Thu, 09 Dec 2021 19:02:21 +0100</pubDate><guid>https://pypyr.io/docs/steps/fetchtoml/</guid><description>pypyr.steps.fetchtoml permalink load &amp;amp; parse toml permalinkParse a toml fie and load it into the pypyr context.
This step requires the following key in the pypyr context:
- name: pypyr.steps.fetchtoml comment: fetch toml from path and store result in key. in: fetchToml: path: ./path.toml # required. path to file on disk. can be relative. key: destinationKey # optional. write toml to this context key. If you do not specify key, the toml structure writes directly to context root.</description></item><item><title>pypyr.steps.add</title><link>https://pypyr.io/docs/steps/add/</link><pubDate>Tue, 05 Oct 2021 16:53:21 +0100</pubDate><guid>https://pypyr.io/docs/steps/add/</guid><description>pypyr.steps.add permalink add item to a set permalinkAdd item(s) to a set.
The difference between a set and a list is that a list allows duplicate elements, whereas every item in a set is unique. If you&amp;rsquo;re looking to work with a list, use append instead. Sets are unordered, lists are ordered.
- name: pypyr.steps.add comment: add item to a set in: add: set: my_set # required. Name of set.</description></item><item><title>pypyr.steps.append</title><link>https://pypyr.io/docs/steps/append/</link><pubDate>Tue, 05 Oct 2021 14:42:26 +0100</pubDate><guid>https://pypyr.io/docs/steps/append/</guid><description>pypyr.steps.append permalink append item to a list permalinkAppend item(s) to the end of a list.
The full input for the append step looks like this:
- name: pypyr.steps.append comment: append item to list in: append: list: my_list # required. Name of list. addMe: list item # required. Append this to the list unpack: False # optional. Defaults False. If True, enumerate addMe &amp;amp; append each item individually. Use the list argument to specify the name of the list.</description></item><item><title>pypyr.steps.pyimport</title><link>https://pypyr.io/docs/steps/pyimport/</link><pubDate>Wed, 25 Nov 2020 18:20:22 +0000</pubDate><guid>https://pypyr.io/docs/steps/pyimport/</guid><description>pypyr.steps.pyimport permalink import references for py strings permalinkImport module &amp;amp; object references to the !py string namespace.
This allows you to use any importable Python code in your !py strings.
- name: pypyr.steps.pyimport comment: any subsequent !py strings can use these objects in: pyImport: | import itertools as itools import math import urllib.parse from pathlib import Path from fractions import Fraction as myfraction - name: pypyr.steps.set comment: use your pyimports anywhere you can use a formatting expression.</description></item><item><title>pypyr.steps.jsonparse</title><link>https://pypyr.io/docs/steps/jsonparse/</link><pubDate>Mon, 26 Oct 2020 13:12:12 +0000</pubDate><guid>https://pypyr.io/docs/steps/jsonparse/</guid><description>pypyr.steps.jsonparse permalink parse json string into context object permalinkParse an input json string into the pypyr context as an object. This allows you to work with the deserialized objects from the json string like you would normally work with any data structures in the pypyr context - so you can use all the usual context handling functionality to set, edit &amp;amp; manipulate context keys and values.
This step requires the jsonParse key in the pypyr context:</description></item><item><title>pypyr.steps.set</title><link>https://pypyr.io/docs/steps/set/</link><pubDate>Mon, 05 Oct 2020 13:28:46 +0100</pubDate><guid>https://pypyr.io/docs/steps/set/</guid><description>pypyr.steps.set permalink set context values with formatting &amp;amp; dynamic expressions permalinkSet context keys with arbitrary values of different types. You can also use formatting expressions for assigning dynamic run-time values with substitutions.
This is roughly the equivalent of instantiating and assigning a variable in traditional programming.
Requires the set key in context. set is a dictionary of items to set in context. For example, here is how you can set arbitrary values with different types to arbitrary keys:</description></item><item><title>pypyraws.steps.ecswaitprep</title><link>https://pypyr.io/docs/plugins/aws/steps/ecswaitprep/</link><pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/steps/ecswaitprep/</guid><description>pypyraws.steps.ecswaitprep permalink wait for ecs state changes permalinkRun me after an ecs task run or stop to prepare an ecs waiter.
Prepares the awsWaitIn context key for pypyraws.steps.wait.
Available ecs waiters are:
ServicesInactive ServicesStable TasksRunning TasksStopped Full details here: http://boto3.readthedocs.io/en/latest/reference/services/ecs.html#waiters
Use this step after any of the following ecs client methods if you want to use one of the ecs waiters to wait for a specific state:
describe_services describe_tasks list_services specify awsEcsWaitPrepCluster if you don&amp;rsquo;t want default list_tasks specify awsEcsWaitPrepCluster if you don&amp;rsquo;t want default run_task start_task stop_task update_service input context permalinkYou don&amp;rsquo;t have to use this step, you could always just construct the awsWaitIn dictionary in context yourself.</description></item><item><title>pypyraws.steps.s3fetchjson</title><link>https://pypyr.io/docs/plugins/aws/steps/s3fetchjson/</link><pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/steps/s3fetchjson/</guid><description>pypyraws.steps.s3fetchjson permalinkFetch a json file from s3 and put the json values into context.
input permalinkRequired input context is:
s3Fetch: clientArgs: # optional arg1Name: arg1Value methodArgs: # mandatory Bucket: &amp;#39;{bucket}&amp;#39; Key: arb.json key: &amp;#39;destination pypyr context key&amp;#39; # optional clientArgs go to the aws s3 client constructor. These are optional. methodArgs go to the the s3 get_object call. The minimum required values are: Bucket Key key writes fetched json to this context key.</description></item><item><title>pypyraws.steps.s3fetchyaml</title><link>https://pypyr.io/docs/plugins/aws/steps/s3fetchyaml/</link><pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/steps/s3fetchyaml/</guid><description>pypyraws.steps.s3fetchyaml permalinkFetch a yaml file from s3 and put the yaml structure into context.
input permalinkRequired input context is:
s3Fetch: clientArgs: # optional arg1Name: arg1Value methodArgs: # mandatory Bucket: &amp;#39;{bucket}&amp;#39; Key: arb.yaml key: &amp;#39;destination pypyr context key&amp;#39; # optional clientArgs go to the aws s3 client constructor. These are optional. methodArgs go to the the s3 get_object call. The minimum required values are: Bucket Key key writes fetched yaml to this context key.</description></item><item><title>pypyrslack.steps.send</title><link>https://pypyr.io/docs/plugins/slack/steps/send/</link><pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/slack/steps/send/</guid><description>pypyrslack.steps.send permalinkSend a message to slack.
input permalinkRequires the following context items:
slackToken your slack api token. Keep this secure. slackChannel send to this slack channel (include # in front) slackText the body of your message. Use your usual slack formatting chars. substitutions permalinkFor all inputs you can use substitution tokens, aka string interpolation. This substitutes anything between curly braces with the context value for that key. For example, if your context looked like this:</description></item><item><title>pypyraws.steps.wait</title><link>https://pypyr.io/docs/plugins/aws/steps/wait/</link><pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/steps/wait/</guid><description>pypyraws.steps.wait permalink wait for aws state changes permalinkWait for things in AWS to complete before continuing pipeline.
Run any low-level boto3 client wait() from get_waiter.
Waiters use a client&amp;rsquo;s service operations to poll the status of an AWS resource and suspend execution until the AWS resource reaches the state that the waiter is polling for or a failure occurs while polling.
http://boto3.readthedocs.io/en/latest/guide/clients.html#waiters
input permalinkThe input context requires:
awsWaitIn: serviceName: &amp;#39;service name&amp;#39; # Available services here: http://boto3.</description></item><item><title>pypyraws.steps.waitfor</title><link>https://pypyr.io/docs/plugins/aws/steps/waitfor/</link><pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/steps/waitfor/</guid><description>pypyraws.steps.waitfor permalink custom waiter for aws state changes permalinkCustom waiter for any aws client operation. Where pypyraws.steps.wait uses the official AWS waiters from the low-level client api, this step allows you to execute any aws low-level client method and wait for a specified field in the response to become the value you want it to be.
AWS does not have waiters for all state changes. Use this to create your own waiter for any property state change.</description></item><item><title>pypyraws.steps.client</title><link>https://pypyr.io/docs/plugins/aws/steps/client/</link><pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/steps/client/</guid><description>pypyraws.steps.client permalink use any low-level aws service client permalinkThis step provides an easy way of getting at the low-level AWS api from the pypyr pipeline runner. So in short, pretty much anything you can do with the AWS api you got it as the Big O might have said.
This step lets you specify the service name and the service method you want to execute dynamically. You can also control the service header arguments and the method arguments themselves.</description></item><item><title>pypyr.steps.contextcopy</title><link>https://pypyr.io/docs/steps/contextcopy/</link><pubDate>Sat, 15 Aug 2020 20:28:42 +0100</pubDate><guid>https://pypyr.io/docs/steps/contextcopy/</guid><description>pypyr.steps.contextcopy permalink copy values &amp;amp; structures from one part of context to another permalinkCopies context values from already existing context values.
This is handy if you need to prepare certain keys in context where a next step might need a specific key. If you already have the value in context, you can create a new key (or update existing key) with that value.
contextcopy and set overwrite existing keys. If you want to merge new values into an existing destination hierarchy, use contextmerge instead.</description></item><item><title>pypyr.steps.assert</title><link>https://pypyr.io/docs/steps/assert/</link><pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/steps/assert/</guid><description>pypyr.steps.assert permalink stop pipeline execution if condition false permalinkAssert that something is True or equal to something else. The step raises an exception of type AssertionError if the assertion fails.
You can express an assert in three different ways:
- name: pypyr.steps.assert comment: evaluates `assert` as truthy in: assert: &amp;#39;{evaluateMe}&amp;#39; - name: pypyr.steps.assert comment: evaluate `this` as truthy in: assert: this: &amp;#39;{evaluateMe}&amp;#39; - name: pypyr.steps.assert comment: assert that two things are equal in: assert: this: &amp;#39;{complexThing1}&amp;#39; equals: &amp;#39;{complexThing2}&amp;#39; The first two mostly do the same thing, so use whichever pleases your eye more.</description></item><item><title>pypyr.steps.call</title><link>https://pypyr.io/docs/steps/call/</link><pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/steps/call/</guid><description>pypyr.steps.call permalink call another step in pipeline permalinkCall (invoke) another step-group in the same pipeline. Once the called group(s) are complete, pypyr continues processing from the point where you initiated the call.
If you want to jump to a different step-group and ignore the rest of the step-group you&amp;rsquo;re in, use pypyr.steps.jump instead.
If you want to switch between calling different step-groups based on an input expression in IF-THEN-ELSE branch style, use pypyr.</description></item><item><title>pypyr.steps.echo</title><link>https://pypyr.io/docs/steps/echo/</link><pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/steps/echo/</guid><description>pypyr.steps.echo permalink write dynamic values to console output stdout permalinkEcho (i.e print) the context value echoMe to the output.
For example, if you had a pipeline like this:
# ./mypipeline.yaml context_parser: pypyr.parser.keyvaluepairs steps: - name: pypyr.steps.echo You can run:
$ pypyr mypipeline &amp;#34;echoMe=Ceci n&amp;#39;est pas une pipe&amp;#34; Alternatively, if you had a pipeline like this:
# ./look-ma-no-params.yaml steps: - name: pypyr.steps.echo comment: Output echoMe in: echoMe: Ceci n&amp;#39;est pas une pipe You can run:</description></item><item><title>custom step</title><link>https://pypyr.io/docs/api/step/</link><pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/step/</guid><description>create a custom step permalinkIf you can&amp;rsquo;t find a ready-made step that quite scratches your particular itch, don&amp;rsquo;t hesitate to code your own step - it&amp;rsquo;s easy, and very much the philosophy of pypyr that if you can write a quick couple of lines of python rather than contort your pipeline with clumsy step sequences, then do so! I know some frameworks don&amp;rsquo;t really encourage you to stray outside the prescribed features, but not so pypyr - your custom steps are first-class citizens of the pypyrverse.</description></item><item><title>pypyr.steps.fileformattoml</title><link>https://pypyr.io/docs/steps/fileformattoml/</link><pubDate>Sat, 11 Jul 2020 17:23:36 +0100</pubDate><guid>https://pypyr.io/docs/steps/fileformattoml/</guid><description>pypyr.steps.fileformattoml permalink find &amp;amp; replace tokens in toml file permalinkParses input toml file and creates an output toml file while substituting {tokens} in the source toml from the pypyr context.
Pretty much does the same thing as pypyr.steps.fileformat, only it makes it easier to work with curly braces for substitutions without tripping over any structural curly braces in the source toml.
This step does not preserve comments or whitespace. Use fileformat or filereplace if you want to preserve comments/whitespace.</description></item><item><title>pypyr.steps.tar</title><link>https://pypyr.io/docs/steps/tar/</link><pubDate>Tue, 07 Jul 2020 17:42:21 +0100</pubDate><guid>https://pypyr.io/docs/steps/tar/</guid><description>pypyr.steps.tar permalink archive &amp;amp; extract tar files with compression permalinkArchive and extract tars with or without compression.
- name: pypyr.steps.tar comment: extract &amp;amp; archive tar in: tar: extract: - in: /path/my.tar out: /out/path archive: - in: /dir/to/archive out: /out/destination.tar format: &amp;#39;&amp;#39; # optional. &amp;#39;&amp;#39; | gz | bz2 | xz Either extract or archive should exist, or both. But not neither.
Optionally, you can also specify the tar compression format with format.</description></item><item><title>pypyr.steps.stopstepgroup</title><link>https://pypyr.io/docs/steps/stopstepgroup/</link><pubDate>Tue, 07 Jul 2020 17:36:13 +0100</pubDate><guid>https://pypyr.io/docs/steps/stopstepgroup/</guid><description>pypyr.steps.stopstepgroup permalinkStop current step-group. Doesn&amp;rsquo;t run any success or failure handlers, it just stops the current step-group.
This is handy if you are using pypyr.steps.call or pypyr.steps.jump to run different step-groups, allowing you to stop just a child step-group but letting the calling parent step-group continue.
You can always use pypyr.steps.stopstepgroup as a simple step, because it doesn&amp;rsquo;t need any input context properties.
If you use a Stop step-group instruction inside a failure handler it will stop processing at that point AND not quit reporting failure.</description></item><item><title>pypyr.steps.stoppipeline</title><link>https://pypyr.io/docs/steps/stoppipeline/</link><pubDate>Tue, 07 Jul 2020 17:26:12 +0100</pubDate><guid>https://pypyr.io/docs/steps/stoppipeline/</guid><description>pypyr.steps.stoppipeline permalink stop current pipeline immediately permalinkStop current pipeline. Doesn&amp;rsquo;t run any success or failure handlers, it just stops the current pipeline.
This is handy if you are using pypyr.steps.pype to call child pipelines from a parent pipeline, allowing you to stop just a child pipeline but letting the parent pipeline continue.
You can always use pypyr.steps.stoppipeline as a simple step, because it doesn&amp;rsquo;t need any input context properties.</description></item><item><title>pypyr.steps.stop</title><link>https://pypyr.io/docs/steps/stop/</link><pubDate>Tue, 07 Jul 2020 17:19:20 +0100</pubDate><guid>https://pypyr.io/docs/steps/stop/</guid><description>pypyr.steps.stop permalink stop pypyr immediately permalinkStop all pypyr processing immediately. Doesn&amp;rsquo;t run any success or failure handlers, it just stops everything in its tracks, even when you&amp;rsquo;re nested in child pipelines or a step-group call-chain.
You can always use pypyr.steps.stop as a simple step, because it doesn&amp;rsquo;t need any input context properties.
If you use a Stop instruction inside a failure handler it will stop processing at that point AND not quit reporting failure.</description></item><item><title>pypyr.steps.shell</title><link>https://pypyr.io/docs/steps/shell/</link><pubDate>Tue, 07 Jul 2020 11:53:28 +0100</pubDate><guid>https://pypyr.io/docs/steps/shell/</guid><description>pypyr.steps.shell permalink run shell statements permalinkRuns the context value cmd in the default shell. On a sensible O/S, this is /bin/sh.
Where the cmd step runs a program or executable, shell passes the command through to the system shell. This means all your usual shell expressions are available, such as ~ expansions and your favorite bashisms.
If you are just looking to run a command or executable with arguments, you do not need to use shell, you can use pypyr.</description></item><item><title>pypyr.steps.safeshell</title><link>https://pypyr.io/docs/steps/safeshell/</link><pubDate>Tue, 07 Jul 2020 11:17:29 +0100</pubDate><guid>https://pypyr.io/docs/steps/safeshell/</guid><description> pypyr.steps.safeshell permalinkDeprecated alias for cmd.
Example pipeline yaml:
steps: - name: pypyr.steps.safeshell in: cmd: ls -a</description></item><item><title>pypyr.steps.nowutc</title><link>https://pypyr.io/docs/steps/nowutc/</link><pubDate>Tue, 07 Jul 2020 10:19:23 +0100</pubDate><guid>https://pypyr.io/docs/steps/nowutc/</guid><description>pypyr.steps.nowutc permalink get current utc timestamp permalinkWrites the current UTC date &amp;amp; time to context nowUtc.
If you want local or wall time, check out pypyr.steps.now instead.
If you run this step as a simple step (with no input nowUtcIn formatting), the default datetime format is ISO8601. For example: YYYY-MM-DDTHH:MM:SS.ffffff+00:00
You can use explicit format strings to control the datetime representation. For a full list of available formatting codes, check python date &amp;amp; time formatting</description></item><item><title>pypyr.steps.now</title><link>https://pypyr.io/docs/steps/now/</link><pubDate>Tue, 07 Jul 2020 10:14:55 +0100</pubDate><guid>https://pypyr.io/docs/steps/now/</guid><description>pypyr.steps.now permalink get current local timestamp permalinkWrites the current local date &amp;amp; time to context now. Local time is also known as wall time.
If you want UTC time, check out pypyr.steps.nowutc instead.
If you run this step as a simple step (with no input formatting specified in nowIn), the default datetime format is ISO8601. For example: YYYY-MM-DDTHH:MM:SS.ffffff+00:00.
You can use explicit format strings to control the datetime representation. For a full list of available formatting codes, check python date &amp;amp; time formatting</description></item><item><title>pypyr.steps.pypyrversion</title><link>https://pypyr.io/docs/steps/pypyrversion/</link><pubDate>Tue, 07 Jul 2020 10:10:38 +0100</pubDate><guid>https://pypyr.io/docs/steps/pypyrversion/</guid><description>pypyr.steps.pypyrversion permalink get current installed version permalinkOutput the same as:
pypyr --version This is an actual pipeline, though, so unlike --version, it&amp;rsquo;ll use the standard pypyr logging format.
Example pipeline yaml:
steps: - pypyr.steps.pypyrversion Since this step does not have any input context, you can always run it as a simple step by just specifying the step-name as a string.</description></item><item><title>pypyr.steps.pype</title><link>https://pypyr.io/docs/steps/pype/</link><pubDate>Mon, 06 Jul 2020 18:44:14 +0100</pubDate><guid>https://pypyr.io/docs/steps/pype/</guid><description>pypyr.steps.pype permalink call another pipeline from current pipeline permalinkRun another pipeline from this step. This allows pipelines to invoke other pipelines. Why pype? Because the pypyr can pipe that song again.
pype is handy if you want to split a larger, cumbersome pipeline into smaller units. This helps testing, in that you can test smaller units as separate pipelines without having to re-run the whole big all-encompassing parent pipeline each time.</description></item><item><title>pypyr.steps.py</title><link>https://pypyr.io/docs/steps/py/</link><pubDate>Mon, 06 Jul 2020 13:17:22 +0100</pubDate><guid>https://pypyr.io/docs/steps/py/</guid><description>pypyr.steps.py permalink run inline python permalinkExecutes the context value py as a dynamically interpreted python code block.
This is useful for adding inline Python code right in your pipeline.
You can use all the usual Python built-ins like len, abs and so forth. You can import standard libraries or your own custom modules &amp;amp; objects using the standard Python import syntax (e.g import x as y, from x import y).</description></item><item><title>pypyr.steps.pathcheck</title><link>https://pypyr.io/docs/steps/pathcheck/</link><pubDate>Mon, 06 Jul 2020 13:06:55 +0100</pubDate><guid>https://pypyr.io/docs/steps/pathcheck/</guid><description>pypyr.steps.pathcheck permalink check if paths exist permalinkCheck if a path exists on the filesystem. Supports globbing. A path can point to a file or a directory.
input permalinkThe pathCheck context key must exist.
- name: pypyr.steps.pathcheck in: pathCheck: ./do/i/exist.arb # single literal path - name: pypyr.steps.pathcheck in: pathCheck: ./**/*.py # single glob expression If you want to check for the existence of multiple paths, you can pass a list instead.</description></item><item><title>pypyr.steps.jump</title><link>https://pypyr.io/docs/steps/jump/</link><pubDate>Mon, 06 Jul 2020 12:43:39 +0100</pubDate><guid>https://pypyr.io/docs/steps/jump/</guid><description>pypyr.steps.jump permalink jump to another step in pipeline permalinkJump to another step-group. This effectively stops processing on the current step-group from which you are jumping.
If you want to return to the point of origin after the step-group you jumped to completes, use call instead.
input permalinkjump expects a context item jump. It can take one of two forms:
- name: pypyr.steps.jump comment: simple string means just call the step-group named &amp;#34;jumphere&amp;#34; in: jump: jumphere - name: pypyr.</description></item><item><title>pypyr.steps.glob</title><link>https://pypyr.io/docs/steps/glob/</link><pubDate>Mon, 06 Jul 2020 12:26:50 +0100</pubDate><guid>https://pypyr.io/docs/steps/glob/</guid><description>pypyr.steps.glob permalink get all matching existing paths from glob permalinkResolve a glob and get all the paths that exist on the filesystem for the input glob.
Any given path can point to a file or a directory.
The glob context key must exist in input context:
- name: pypyr.steps.glob in: glob: ./**/*.py # single glob If you want to resolve multiple globs simultaneously and combine the results, you can pass a list instead.</description></item><item><title>pypyr.steps.filewriteyaml</title><link>https://pypyr.io/docs/steps/filewriteyaml/</link><pubDate>Mon, 06 Jul 2020 12:07:43 +0100</pubDate><guid>https://pypyr.io/docs/steps/filewriteyaml/</guid><description>pypyr.steps.filewriteyaml permalink create yaml file from any context object permalinkFormat &amp;amp; write a payload to a yaml file on disk. This is useful for generating yaml files from your pipeline such as when you want to create configuration files dynamically on the fly.
filewriteyaml works like this:
- name: pypyr.steps.filewriteyaml comment: write context payload out to yaml in: fileWriteYaml: path: /path/to/output.yaml # destination file payload: # (optional) payload to write to path key1: value1 # output yaml will have key2: value2 # key1 and key2 as string.</description></item><item><title>pypyr.steps.filewritejson</title><link>https://pypyr.io/docs/steps/filewritejson/</link><pubDate>Mon, 06 Jul 2020 11:38:51 +0100</pubDate><guid>https://pypyr.io/docs/steps/filewritejson/</guid><description>pypyr.steps.filewritejson permalink create json file from any context object permalinkFormat &amp;amp; write a payload to a json file on disk. This is useful for generating json files from your pipeline such as when you want to create configuration files dynamically on the fly.
filewritejson works like this:
- name: pypyr.steps.filewritejson comment: write context payload out to json in: fileWriteJson: path: /path/to/output.json # destination file payload: # (optional) payload to write to path key1: value1 # output json will have key2: value2 # key1 and key2 as string key3: 124 # output int key4: false # output bool This will generate the following json to /path/to/output.</description></item><item><title>pypyr.steps.filereplace</title><link>https://pypyr.io/docs/steps/filereplace/</link><pubDate>Fri, 03 Jul 2020 18:00:13 +0100</pubDate><guid>https://pypyr.io/docs/steps/filereplace/</guid><description>pypyr.steps.filereplace permalink find &amp;amp; replace arbitrary strings in a file permalinkParses input text file and replaces any given search strings.
The other fileformat steps, by way of contradistinction, uses string formatting expressions inside {braces} to format values against the pypyr context.
This step, however, lets you find any arbitrary search string and replace it with any replacement string. This is especially handy if you are working with a file where curly braces aren&amp;rsquo;t helpful for a formatting expression - e.</description></item><item><title>pypyr.steps.fileformatyaml</title><link>https://pypyr.io/docs/steps/fileformatyaml/</link><pubDate>Thu, 02 Jul 2020 17:23:36 +0100</pubDate><guid>https://pypyr.io/docs/steps/fileformatyaml/</guid><description>pypyr.steps.fileformatyaml permalink find &amp;amp; replace tokens in yaml file permalinkParses input yaml file and substitutes {tokens} from the pypyr context.
Pretty much does the same thing as pypyr.steps.fileformat, only it makes it easier to work with curly braces for substitutions without tripping over the yaml&amp;rsquo;s structural braces.
If your yaml doesn&amp;rsquo;t use curly braces that aren&amp;rsquo;t meant for {token} substitutions, you can happily use pypyr.steps.fileformat instead - it&amp;rsquo;s more memory efficient.</description></item><item><title>pypyr.steps.fileformatjson</title><link>https://pypyr.io/docs/steps/fileformatjson/</link><pubDate>Thu, 02 Jul 2020 17:23:30 +0100</pubDate><guid>https://pypyr.io/docs/steps/fileformatjson/</guid><description>pypyr.steps.fileformatjson permalink find &amp;amp; replace tokens in json permalinkParses input json file and substitutes {tokens} from the pypyr context.
Pretty much does the same thing as pypyr.steps.fileformat, only it makes it easier to work with curly braces for substitutions without tripping over the json&amp;rsquo;s structural braces.
Given input json like this:
{ &amp;#34;k1&amp;#34;: &amp;#34;v1&amp;#34;, &amp;#34;k2&amp;#34;: { &amp;#34;k2.1&amp;#34;: &amp;#34;v2.1&amp;#34;, &amp;#34;k2.2&amp;#34;: [ &amp;#34;2.2.1&amp;#34;, &amp;#34;START {replaceMeNested} END&amp;#34; ] }, &amp;#34;k3&amp;#34;: &amp;#34;{replaceMeString}&amp;#34;, &amp;#34;k4&amp;#34;: &amp;#34;{replaceMeInt}&amp;#34;, &amp;#34;k5&amp;#34;: &amp;#34;{replaceMeBool}&amp;#34;, &amp;#34;{replaceMeKey}&amp;#34;: &amp;#34;this will replace the key&amp;#34; } And a pipeline like this:</description></item><item><title>pypyr.steps.fileformat</title><link>https://pypyr.io/docs/steps/fileformat/</link><pubDate>Wed, 01 Jul 2020 20:17:37 +0100</pubDate><guid>https://pypyr.io/docs/steps/fileformat/</guid><description>pypyr.steps.fileformat permalink find &amp;amp; replace tokens in text files permalinkParses input text file, substitutes {tokens} in the text of the file from the pypyr context and writes the result to an output file.
- name: pypyr.steps.fileformat comment: read a file from disk, do some substitutions, write back to disk. in: fileFormat: in: ./in/arb.txt # required out: ./out/arb.txt # optional So if you had a text file in/arb.txt like this:</description></item><item><title>pypyr.steps.fetchyaml</title><link>https://pypyr.io/docs/steps/fetchyaml/</link><pubDate>Wed, 01 Jul 2020 20:02:35 +0100</pubDate><guid>https://pypyr.io/docs/steps/fetchyaml/</guid><description>pypyr.steps.fetchyaml permalink load &amp;amp; parse yaml permalinkLoads a yaml file into the pypyr context.
This step requires the following key in the pypyr context:
- name: pypyr.steps.fetchyaml description: fetch yaml from path in: fetchYaml: path: ./path.yaml # required. path to file on disk. can be relative. key: destinationKey # optional. write yaml to this context key. If you do not specify key, yaml writes directly to context root.
If you do not want to specify a key, you can also use the streamlined format:</description></item><item><title>pypyr.steps.fetchjson</title><link>https://pypyr.io/docs/steps/fetchjson/</link><pubDate>Wed, 01 Jul 2020 19:02:21 +0100</pubDate><guid>https://pypyr.io/docs/steps/fetchjson/</guid><description>pypyr.steps.fetchjson permalink load &amp;amp; parse json permalinkLoads a json file into the pypyr context.
This step requires the following key in the pypyr context:
- name: pypyr.steps.fetchjson comment: fetch json from path in: fetchJson: path: ./path.json # required. path to file on disk. can be relative. key: destinationKey # optional. write json to this context key. If you do not specify key, json writes directly to context root.
If you do not want to specify a key, you can also use the streamlined format:</description></item><item><title>pypyr.steps.envget</title><link>https://pypyr.io/docs/steps/envget/</link><pubDate>Wed, 01 Jul 2020 17:19:44 +0100</pubDate><guid>https://pypyr.io/docs/steps/envget/</guid><description>pypyr.steps.envget permalink get environment variables into context permalinkGet environment variables, and assign an optional default value to context if the sought environment variables do not exist.
The difference between pypyr.steps.envget and pypyr.steps.env , is that pypyr.steps.envget won&amp;rsquo;t raise an error if the $ENV doesn&amp;rsquo;t exist.
The envget context key must exist.
All inputs support substitutions.
See a worked example for getting environment variables with defaults here.
get an environment variable with a default fallback permalink - name: pypyr.</description></item><item><title>pypyr.steps.env</title><link>https://pypyr.io/docs/steps/env/</link><pubDate>Wed, 01 Jul 2020 17:11:02 +0100</pubDate><guid>https://pypyr.io/docs/steps/env/</guid><description>pypyr.steps.env permalink use environment variables in your pipeline permalinkGet, set or unset environment variables.
The env context key must exist. env can contain a combination of get, set and unset keys. You must specify at least one of get, set and unset.
env: get: contextkey1: env1 contextkey2: env2 set: env1: value1 env2: value2 unset: - env1 - env2 This step will run whatever combination of Get, Set and Unset you specify.</description></item><item><title>pypyr.steps.default</title><link>https://pypyr.io/docs/steps/default/</link><pubDate>Wed, 01 Jul 2020 12:22:55 +0100</pubDate><guid>https://pypyr.io/docs/steps/default/</guid><description>pypyr.steps.default permalink initialize the context with default values permalinkSets values in context if they do not exist already. Does not overwrite existing values. Supports nested hierarchies.
This is especially useful for setting default values in context, for example when using optional arguments from the cli.
This step sets the contents of the context key defaults into context where keys in defaults do not exist in context already. The contents of the defaults key must be a dictionary.</description></item><item><title>pypyr.steps.debug</title><link>https://pypyr.io/docs/steps/debug/</link><pubDate>Wed, 01 Jul 2020 12:03:17 +0100</pubDate><guid>https://pypyr.io/docs/steps/debug/</guid><description>pypyr.steps.debug permalink debug the context permalinkPretty print the context to output.
Print the pypyr context to the pypyr output. This is likely to be the console. This may assist in debugging when trying to see what values are what.
debug prints to the INFO (20) log-level. This means you won&amp;rsquo;t see debug output unless you specify pypyr mypype --log 20 or lower value for log. If you have values you that always want to print to output, echo is the more natural step to use.</description></item><item><title>pypyr.steps.contextsetf</title><link>https://pypyr.io/docs/steps/contextsetf/</link><pubDate>Tue, 30 Jun 2020 20:28:46 +0100</pubDate><guid>https://pypyr.io/docs/steps/contextsetf/</guid><description>pypyr.steps.contextsetf permalinkUse pypyr.steps.set instead - it does the same thing but the name is shorter so less typing, woo! Your keyboard will thank you in the long run.
Although contextsetf is not going anywhere, new updates &amp;amp; fixes will only go to set.</description></item><item><title>pypyr.steps.contextmerge</title><link>https://pypyr.io/docs/steps/contextmerge/</link><pubDate>Tue, 30 Jun 2020 19:51:26 +0100</pubDate><guid>https://pypyr.io/docs/steps/contextmerge/</guid><description>pypyr.steps.contextmerge permalink merging context values permalinkMerges values into context, preserving the existing hierarchy while only updating the differing values as specified in the contextMerge input.
By comparison, contextcopy and set overwrite the destination hierarchy that is in context already.
This step merges the contents of the context key contextMerge into context. The contents of the contextMerge key must be a dictionary.
examples permalinkFor example, say input context is:
key1: value1 key2: value2 key3: k31: value31 k32: value32 contextMerge: key2: &amp;#39;aaa_{key1}_zzz&amp;#39; key3: k33: value33_{key1} key4: &amp;#39;bbb_{key2}_yyy&amp;#39; This will result in return context:</description></item><item><title>pypyr.steps.contextclearall</title><link>https://pypyr.io/docs/steps/contextclearall/</link><pubDate>Tue, 30 Jun 2020 19:04:00 +0100</pubDate><guid>https://pypyr.io/docs/steps/contextclearall/</guid><description>pypyr.steps.contextclearall permalinkWipe the entire context. No input context arguments required.
You can always use contextclearall as a simple step, since it does not require any input context.
Sample pipeline yaml:
steps: - my.arb.step - pypyr.steps.contextclearall - another.arb.step contextclearall also wipes all the imports from any preceding pyimport steps.</description></item><item><title>pypyr.steps.contextclear</title><link>https://pypyr.io/docs/steps/contextclear/</link><pubDate>Tue, 30 Jun 2020 19:03:21 +0100</pubDate><guid>https://pypyr.io/docs/steps/contextclear/</guid><description>pypyr.steps.contextclear permalinkRemove the specified items from the context.
Will iterate contextClear and remove those keys from context.
steps: - name: pypyr.steps.contextclear description: delete these 2 context keys in: contextClear: - removeMe - removeMeToo For example, say input context is:
key1: value1 key2: value2 key3: value3 key4: value4 contextClear: - key2 - key4 - contextClear This will result in return context:
key1: value1 key3: value3 Notice how contextClear also cleared itself in this example.</description></item><item><title>pypyr.steps.cmd</title><link>https://pypyr.io/docs/steps/cmd/</link><pubDate>Sat, 13 Jun 2020 21:38:57 +0100</pubDate><guid>https://pypyr.io/docs/steps/cmd/</guid><description>pypyr.steps.cmd permalink execute external commands, applications &amp;amp; scripts permalinkRun a program, run an external script, application or command. Execute an executable as a sub-process.
cmd runs an executable, it does not invoke the shell. You cannot use shell features like exit, return, shell pipes, filename wildcards, environment variable expansion, and expansion of ~ to a user&amp;rsquo;s home directory. Use pypyr.steps.shell for that instead.
This step runs executables serially one after the other.</description></item></channel></rss>