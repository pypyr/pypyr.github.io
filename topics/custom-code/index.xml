<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>custom code on pypyr</title><link>https://pypyr.io/topics/custom-code/</link><description>Recent content in custom code on pypyr</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 21 Sep 2023 22:48:43 -0700</lastBuildDate><atom:link href="https://pypyr.io/topics/custom-code/index.xml" rel="self" type="application/rss+xml"/><item><title>custom module name resolution</title><link>https://pypyr.io/docs/api/custom-module-search-path/</link><pubDate>Mon, 15 Nov 2021 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/custom-module-search-path/</guid><description>reference custom modules in your pipeline permalink TLDR:
Custom modules resolve relative to the current pipeline.
Although you can also resolve from the current directory as a fallback, this will make your pipeline less portable than it should be.
Prefer only using absolute names relative to the pipeline itself.
Each custom step, parser, loader &amp;amp; retry algo you write lives in a .py file. In Python speak, this .py file is known as a &amp;ldquo;module&amp;rdquo;.</description></item><item><title>custom retry backoff</title><link>https://pypyr.io/docs/api/retry-backoff/</link><pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/retry-backoff/</guid><description>create a custom retry backoff algorithm permalink custom retry backoff algorithms permalinkA retry backoff strategy is an algorithm that varies the backoff interval between retries. If you do not want to use one of the builtin common backoff retry strategies, you can implement your own by deriving a callable from BackoffBase, which lives in pypyr.retries.
For real life inspiration, you can see all of pypyr&amp;rsquo;s builtin retry backoff implementations on github.</description></item><item><title>api</title><link>https://pypyr.io/docs/api/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/</guid><description>the pypyr api permalinkYou can easily extend pypyr with your own custom steps, cli input arguments &amp;amp; you can invoke pipelines programmatically from the API.
At simplest, you can run a pipeline with one line of code.
Don&amp;rsquo;t be put off &amp;amp; think of this as advanced functionality: it is very much the idea of how to use pypyr effectively. Specifically making your own custom step is likely to be a regular activity - and happily, you can do so with a single simple function signature.</description></item><item><title>custom context parser</title><link>https://pypyr.io/docs/api/context-parser/</link><pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/context-parser/</guid><description>create a custom context parser permalink parse custom cli arguments permalinkA context_parser parses the pypyr cli input arguments. Simply put, this is all the positional arguments after the pipeline-name in the cli.
$ pypyr pipelinename this is the args input In this example, ['this', 'is', 'the', 'args', 'input'] will go to the pipeline&amp;rsquo;s context parser as input.
Generally, a context_parser is likely to take the input args list and create a dict with it somehow.</description></item><item><title>custom pype loader</title><link>https://pypyr.io/docs/api/pipeline-loader/</link><pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/pipeline-loader/</guid><description>create a custom pipeline loader permalink load pipeline not on the local filesystem permalinkA pype loader is responsible for loading a pipeline.
The default pype loader is pypyr.loaders.file. You can change this default in config for default_loader.
This default loader loads pipelines from the local file-system, following the usual pypyr pipeline look-up sequence.
You can find all of pypyr&amp;rsquo;s built-in loaders here.
If you want to load pipelines from somewhere else, like maybe a shared pipeline library, or implement your own caching, or maybe if you want to load a pipeline from something like s3 or consul, you can roll your own pype loader.</description></item><item><title>developer's guide for pypyr</title><link>https://pypyr.io/docs/contributing/developers-guide/</link><pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/contributing/developers-guide/</guid><description>developer&amp;rsquo;s guide permalink coding style permalinkYou&amp;rsquo;ve read pep8? pypyr uses flake8 as a quality gate during ci.
testing without worrying about dependencies permalinkRun tox to test the packaging cycle inside a tox virtual env, plus run all tests:
# run tests &amp;amp; flake 8 linter $ tox -- ops/build # run tests, flake 8 linter, test packaging &amp;amp; validate README.rst $ tox -- ops/build package This of course assumes you have tox installed in your current active Python environment.</description></item><item><title>run pipeline api</title><link>https://pypyr.io/docs/api/run-pipeline/</link><pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/run-pipeline/</guid><description>run a pipeline from the api permalinkYou can run a pypyr automation pipeline programmatically from your own code using the python api.
Here&amp;rsquo;s a silly pipeline:
# ./pipeline-dir/my-pipe.yaml context_parser: pypyr.parser.keyvaluepairs steps: - name: pypyr.steps.echo in: echoMe: piper {arbkey} that {anotherkey} again - name: pypyr.steps.set in: set: myoutput: I was set in the pipeline! input_values: - &amp;#39;{arbkey}&amp;#39; - &amp;#39;{anotherkey}&amp;#39; some_nesting: down_level: arb_number: 123 arb_bool: False Run this pipeline from the cli like this:</description></item><item><title>custom step</title><link>https://pypyr.io/docs/api/step/</link><pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/step/</guid><description>create a custom step permalinkIf you can&amp;rsquo;t find a ready-made step that quite scratches your particular itch, don&amp;rsquo;t hesitate to code your own step - it&amp;rsquo;s easy, and very much the philosophy of pypyr that if you can write a quick couple of lines of python rather than contort your pipeline with clumsy step sequences, then do so! I know some frameworks don&amp;rsquo;t really encourage you to stray outside the prescribed features, but not so pypyr - your custom steps are first-class citizens of the pypyrverse.</description></item></channel></rss>