<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>control-of-flow on pypyr</title><link>https://pypyr.io/topics/control-of-flow/</link><description>Recent content in control-of-flow on pypyr</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 12 Aug 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://pypyr.io/topics/control-of-flow/index.xml" rel="self" type="application/rss+xml"/><item><title>conditional logic</title><link>https://pypyr.io/docs/getting-started/conditional-logic/</link><pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/getting-started/conditional-logic/</guid><description>conditional logic permalink selectively run or skip step permalinkYou can control the flow of execution in your pipeline by selectively running or skipping a step based upon whether a conditional statement evaluates to True.
You use the run or skip decorators on any step to set your condition whether to execute the step.
By default, unless you explicitly tell pypyr differently, every step will run.
# getting-started/basic-conditional.yaml steps: - name: pypyr.</description></item><item><title>loops</title><link>https://pypyr.io/docs/getting-started/loops/</link><pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/getting-started/loops/</guid><description>loops permalinkYou can loop (or iterate) over any given step in a pypyr pipeline.
This means you can repeatedly run or loop over your own custom commands without writing any code.
Looping happens on the step-level, using the following step decorators:
foreach while The difference is that foreach iterates over every element in an iterable (such as a list), whereas while keeps on looping until a stop condition evaluates True.</description></item><item><title>pypyr.steps.assert</title><link>https://pypyr.io/docs/steps/assert/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/steps/assert/</guid><description>pypyr.steps.assert permalink stop pipeline execution if condition false permalinkAssert that something is True or equal to something else. The step raises an exception of type AssertionError if the assertion fails.
You can express an assert in three different ways:
- name: pypyr.steps.assert comment: evaluates `assert` as truthy in: assert: &amp;#39;{evaluateMe}&amp;#39; - name: pypyr.steps.assert comment: evaluate `this` as truthy in: assert: this: &amp;#39;{evaluateMe}&amp;#39; - name: pypyr.steps.assert comment: assert that two things are equal in: assert: this: &amp;#39;{complexThing1}&amp;#39; equals: &amp;#39;{complexThing2}&amp;#39; The first two mostly do the same thing, so use whichever pleases your eye more.</description></item><item><title>pypyr.steps.call</title><link>https://pypyr.io/docs/steps/call/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/steps/call/</guid><description>pypyr.steps.call permalink call another step in pipeline permalinkCall (invoke) another step-group in the same pipeline. Once the called group(s) are complete, pypyr continues processing from the point where you initiated the call.
If you want to jump to a different step-group and ignore the rest of the step-group you&amp;rsquo;re in, use pypyr.steps.jump instead.
input permalinkcall expects a context item call. It can take one of two forms:
- name: pypyr.</description></item><item><title>while loop decorator</title><link>https://pypyr.io/docs/decorators/while/</link><pubDate>Tue, 14 Jul 2020 13:09:24 +0100</pubDate><guid>https://pypyr.io/docs/decorators/while/</guid><description>while permalink repeat step(s) in while loop permalinkRepeat step until stop is True, or until you reach a configurable maximum iterations. You have to specify at least one of either max or stop.
If you specify both max and stop, the loop exits when stop is True as long as it&amp;rsquo;s still under max iterations.
max will exit the loop even if stop is still False. If you want to error and stop processing when max exhausts set errorOnMax to True.</description></item><item><title>skip decorator</title><link>https://pypyr.io/docs/decorators/skip/</link><pubDate>Tue, 14 Jul 2020 11:38:26 +0100</pubDate><guid>https://pypyr.io/docs/decorators/skip/</guid><description>skip permalink selectively skip step permalinkSkip this step if True, run step if False. Evaluates after the run decorator. This means that if run is False, the step will never run, regardless of skip.
Default is False. This means by default pypyr will not skip a step.
If this looks like it&amp;rsquo;s merely the inverse of run, that&amp;rsquo;s because it is. Use whichever suits your pipeline better, or combine run and skip in the same pipeline to toggle at runtime which steps you want to execute.</description></item><item><title>run decorator</title><link>https://pypyr.io/docs/decorators/run/</link><pubDate>Tue, 14 Jul 2020 11:02:07 +0100</pubDate><guid>https://pypyr.io/docs/decorators/run/</guid><description>run permalink selectively run step permalinkRuns this step if True, skips step if False.
Default is True. The means by default pypyr will run a step unless you tell it otherwise.
You&amp;rsquo;ll almost always use run with substitutions, so you set the value at run-time from context.
set run with substitution expressions permalinkYou can use truthy expressions with run, skip and swallow. This means you can selectively run a step depending on if an object is not null and evaluates truthy.</description></item><item><title>foreach loop decorator</title><link>https://pypyr.io/docs/decorators/foreach/</link><pubDate>Fri, 10 Jul 2020 19:07:51 +0100</pubDate><guid>https://pypyr.io/docs/decorators/foreach/</guid><description>foreach permalink repeat step for each item in list permalinkRun the step once for each item in the list.
The iterator is context['i']. If you want to use the iterator value in your step with a substitution expression, you&amp;rsquo;d use {i}.
foreach takes any iterable. In your pipeline yaml, you can specify this as a list [] in two ways:
foreach: [item 1, item 2, item 3] or
foreach: - item 1 - item 2 - item 3 loop static input list permalinkThe foreach input here is a standard list.</description></item><item><title>pypyr.steps.stopstepgroup</title><link>https://pypyr.io/docs/steps/stopstepgroup/</link><pubDate>Tue, 07 Jul 2020 17:36:13 +0100</pubDate><guid>https://pypyr.io/docs/steps/stopstepgroup/</guid><description>pypyr.steps.stopstepgroup permalinkStop current step-group. Doesn&amp;rsquo;t run any success or failure handlers, it just stops the current step-group.
This is handy if you are using pypyr.steps.call or pypyr.steps.jump to run different step-groups, allowing you to stop just a child step-group but letting the calling parent step-group continue.
You can always use pypyr.steps.stopstepgroup as a simple step, because it doesn&amp;rsquo;t need any input context properties.
If you use a Stop step-group instruction inside a failure handler it will stop processing at that point AND not quit reporting failure.</description></item><item><title>pypyr.steps.stoppipeline</title><link>https://pypyr.io/docs/steps/stoppipeline/</link><pubDate>Tue, 07 Jul 2020 17:26:12 +0100</pubDate><guid>https://pypyr.io/docs/steps/stoppipeline/</guid><description>pypyr.steps.stoppipeline permalink stop current pipeline immediately permalinkStop current pipeline. Doesn&amp;rsquo;t run any success or failure handlers, it just stops the current pipeline.
This is handy if you are using pypyr.steps.pype to call child pipelines from a parent pipeline, allowing you to stop just a child pipeline but letting the parent pipeline continue.
You can always use pypyr.steps.stoppipeline as a simple step, because it doesn&amp;rsquo;t need any input context properties.</description></item><item><title>pypyr.steps.stop</title><link>https://pypyr.io/docs/steps/stop/</link><pubDate>Tue, 07 Jul 2020 17:19:20 +0100</pubDate><guid>https://pypyr.io/docs/steps/stop/</guid><description>pypyr.steps.stop permalink stop pypyr immediately permalinkStop all pypyr processing immediately. Doesn&amp;rsquo;t run any success or failure handlers, it just stops everything in its tracks, even when you&amp;rsquo;re nested in child pipelines or a step-group call-chain.
You can always use pypyr.steps.stop as a simple step, because it doesn&amp;rsquo;t need any input context properties.
If you use a Stop instruction inside a failure handler it will stop processing at that point AND not quit reporting failure.</description></item><item><title>pypyr.steps.pype</title><link>https://pypyr.io/docs/steps/pype/</link><pubDate>Mon, 06 Jul 2020 18:44:14 +0100</pubDate><guid>https://pypyr.io/docs/steps/pype/</guid><description>pypyr.steps.pype permalink call another pipeline from current pipeline permalinkRun another pipeline from this step. This allows pipelines to invoke other pipelines. Why pype? Because the pypyr can pipe that song again.
pype is handy if you want to split a larger, cumbersome pipeline into smaller units. This helps testing, in that you can test smaller units as separate pipelines without having to re-run the whole big all-encompassing parent pipeline each time.</description></item><item><title>pypyr.steps.jump</title><link>https://pypyr.io/docs/steps/jump/</link><pubDate>Mon, 06 Jul 2020 12:43:39 +0100</pubDate><guid>https://pypyr.io/docs/steps/jump/</guid><description>pypyr.steps.jump permalink jump to another step in pipeline permalinkJump to another step-group. This effectively stops processing on the current step-group from which you are jumping.
If you want to return to the point of origin after the step-group you jumped to completes, use call instead.
input permalinkjump expects a context item jump. It can take one of two forms:
- name: pypyr.steps.jump comment: simple string means just call the step-group named &amp;#34;jumphere&amp;#34; in: jump: jumphere - name: pypyr.</description></item></channel></rss>