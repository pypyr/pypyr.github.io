<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>task-runner for automation pipelines defined in yaml on pypyr</title><link>https://pypyr.io/</link><description>Recent content in task-runner for automation pipelines defined in yaml on pypyr</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 12 Aug 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://pypyr.io/index.xml" rel="self" type="application/rss+xml"/><item><title>install pypyr</title><link>https://pypyr.io/docs/getting-started/installation/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/getting-started/installation/</guid><description> install pypyr permalink pip permalink$ pip install pypyr upgrades permalinkUse the standard pip upgrade switch:
$ pip install --upgrade pypyr python version permalinkTested against Python &amp;gt;=3.6
docker permalinkStuck with an older version of python? Want to run pypyr in an environment that you don&amp;rsquo;t control, like a CI server somewhere?
You can use the official pypyr docker image as a drop-in replacement for the pypyr executable.
$ docker run pypyr/pypyr echo &amp;#34;Ceci n&amp;#39;est pas une pipe&amp;#34;</description></item><item><title>run your first pipeline</title><link>https://pypyr.io/docs/getting-started/run-your-first-pipeline/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/getting-started/run-your-first-pipeline/</guid><description>run your first pipeline permalink run a built-in pipeline permalinkRun one of the built-in pipelines to get a feel for it:
$ pypyr echo &amp;#34;Ceci n&amp;#39;est pas une pipe&amp;#34; echo is the name of a built-in pypyr pipeline. The pipeline simply echoes the input string back to console output using the built-in echo step.
The actual pipeline looks like this:
# To execute this pipeline, shell something like:# pypyr echo text goes herecontext_parser:pypyr.</description></item><item><title>basic concepts</title><link>https://pypyr.io/docs/getting-started/basic-concepts/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/getting-started/basic-concepts/</guid><description>basic concepts permalink pipeline permalinkA pipeline is a sequence of steps. A pypyr pipeline is a simple human-readable and human-authored yaml file that defines your sequence of steps. pypyr interprets and runs the pipeline for you.
# ./arb-example-pipeline.yaml# optionalcontext_parser:my.custom.parser# how you pass cli arguments to the pipeline.# mandatorysteps:# step-group- step1# run ./step1.py- step2# run ./step2.py# optional.on_success:# step-group- my.first.success.step# run ./my/first/success/step.py- my.second.success.step# run ./my/second/success/step.py# optional.on_failure:# step-group- my.failure.handler.step# run ./my/failure/handler/step.py- my.failure.handler.notifier# run .</description></item><item><title>variables</title><link>https://pypyr.io/docs/getting-started/variables/</link><pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/getting-started/variables/</guid><description>how to use variables in a pypyr pipeline permalinkYou can use variables to parameterize your pypyr pipelines and pass values between steps. pypyr lets you pass values seamlessly between the pipeline yaml, the cli (or api) and the steps in the pipeline.
pypyr stores variables in the context. The context is a dictionary that stays in scope for the duration of the entire pipeline.
Variables can be simple types like string or int, and they can also contain complex nested structures like dictionaries or lists.</description></item><item><title>conditional logic</title><link>https://pypyr.io/docs/getting-started/conditional-logic/</link><pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/getting-started/conditional-logic/</guid><description>conditional logic permalink selectively run or skip step permalinkYou can control the flow of execution in your pipeline by selectively running or skipping a step based upon whether a conditional statement evaluates to True.
You use the run or skip decorators on any step to set your condition whether to execute the step.
By default, unless you explicitly tell pypyr differently, every step will run.
# getting-started/basic-conditional.yamlsteps:- name:pypyr.steps.echoin:echoMe:begin- name:pypyr.steps.cmdrun:Falsein:cmd:echo this will not run- name:pypyr.</description></item><item><title>error handling</title><link>https://pypyr.io/docs/getting-started/error-handling/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/getting-started/error-handling/</guid><description>error handling permalink stop all processing on error permalinkpypyr runs pipelines. . . and a pipeline is a sequence of steps. By default subsequent steps in the sequence should not run if a previous step failed.
If your desired behavior is for pipeline processing to stop and subsequent steps NOT to run once an error occurs somewhere, you don&amp;rsquo;t have to do anything special, because this is what pypyr does by default.</description></item><item><title>pipeline yaml structure</title><link>https://pypyr.io/docs/pipelines/pipeline-structure/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/pipelines/pipeline-structure/</guid><description>pipeline yaml structure permalink pypyr pipeline format permalinkA pipeline is a .yaml file. pypyr uses YAML version 1.2.
Save pipelines wherever you please. To run a pipeline, execute pypyr pipelinename from the directory where you saved pipelinename.yaml
# This is an example showing the anatomy of a pypyr pipeline# A pipeline should be saved as {working dir}/mypipelinename.yaml.# Run the pipeline from {working dir} like this: pypyr mypipelinename# optional. set this to pass cli arguments to the pipeline.</description></item><item><title>pipeline look-up order</title><link>https://pypyr.io/docs/pipelines/lookup-order/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/pipelines/lookup-order/</guid><description>pipeline look-up order permalink the working directory permalinkpypyr first looks for pipelines, any custom steps &amp;amp; other code in the current working directory. This is the directory from which you invoke pypyr.
Simply put, by default, this is the directory you&amp;rsquo;re currently in when you invoke pypyr from the cli.
You can change the default working directory by passing the --dir flag to pypyr CLI. pypyr will use whatever path you specify in --dir as the working directory base path.</description></item><item><title>run a pipeline with the pypyr cli</title><link>https://pypyr.io/docs/cli/run-a-pipeline/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/cli/run-a-pipeline/</guid><description>run a pipeline from the cli permalink pass arguments &amp;amp; command line switches to the cli permalinkpypyr runs the pipeline specified by the name that you pass to the cli.
To make your pipelines edit easier in your favorite yaml editor, use a .yaml extension, but to save on typing you don&amp;rsquo;t need to enter the .yaml bit at the command line.
You can use your usual directory separators if you&amp;rsquo;re running a pipeline in a sub-directory, like $ pypyr subdir/subsubdir/pipeline</description></item><item><title>pypyr release v4.5.0</title><link>https://pypyr.io/updates/releases/v4.5.0/</link><pubDate>Tue, 02 Feb 2021 11:18:53 +0000</pubDate><guid>https://pypyr.io/updates/releases/v4.5.0/</guid><description>pypyr release v4.5.0 permalink retry backoff &amp;amp; cleaner api init permalinkRelease Date: 2021-02-02T11:18:53Z
Add retry backoff strategies. You can now use retry backoff algorithms like exponential or linear to control the sleep interval in between retries. The default fixed retry sleep interval now supports a list input, so the next sleep interval between retries can come from a list you provide yourself. Ref #216. For API consumers: Prevent duplicates in sys.</description></item><item><title>custom retry backoff</title><link>https://pypyr.io/docs/api/retry-backoff/</link><pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/retry-backoff/</guid><description>create a custom retry backoff algorithm permalink custom retry backoff algorithms permalinkA retry backoff strategy is an algorithm that varies the backoff interval between retries. If you do not want to use one of the builtin common backoff retry strategies, you can implement your own by deriving a callable from BackoffBase, which lives in pypyr.retries.
For real life inspiration, you can see all of pypyr&amp;rsquo;s builtin retry backoff implementations on github.</description></item><item><title>pypyr release v4.4.1</title><link>https://pypyr.io/updates/releases/v4.4.1/</link><pubDate>Fri, 01 Jan 2021 14:54:19 +0000</pubDate><guid>https://pypyr.io/updates/releases/v4.4.1/</guid><description>pypyr release v4.4.1 permalink context parser initialize to empty rather than None permalinkRelease Date: 2021-01-01T14:54:19Z
Context parsers that create an entry in context now initialize to empty rather than None. This means you can directly use something like {argList}, {argDict} and argString (initializing respectively to [], {}, '') directly for things like foreach loops without having to worry about None checks. Your existing truthy checks for these values will work as before.</description></item><item><title>pypyr release v4.4.0</title><link>https://pypyr.io/updates/releases/v4.4.0/</link><pubDate>Sat, 26 Dec 2020 15:50:27 +0000</pubDate><guid>https://pypyr.io/updates/releases/v4.4.0/</guid><description>pypyr release v4.4.0 permalink simplified py step syntax &amp;amp; imports for !py strings. permalinkRelease Date: 2020-12-26T15:50:27Z
New step pypyr.steps.pyimport to import references to the !py string namespace. This includes an underlying api signature change by removal of pypyr.utils.expressions.eval_string(), but this is sufficiently far down the call-chain that it shouldnâ€™t affect any normal pipeline operator or api consumer. pypyr.steps.contextclearall wipes pyimport imported references in addition to the key/values inside context.</description></item><item><title>pypyr.steps.pyimport</title><link>https://pypyr.io/docs/steps/pyimport/</link><pubDate>Wed, 25 Nov 2020 18:20:22 +0000</pubDate><guid>https://pypyr.io/docs/steps/pyimport/</guid><description>pypyr.steps.pyimport permalink import references for py strings permalinkImport module &amp;amp; object references to the !py string namespace.
This allows you to use any importable Python code in your !py strings.
- name:pypyr.steps.pyimportcomment:any subsequent !py strings can use these objectsin:pyImport:|import itertools as itools import math import urllib.parse from pathlib import Path from fractions import Fraction as myfraction - name:pypyr.steps.contextsetfcomment:use your pyimports anywhere you can use a formatting expression.here using it to eval a bool for the &amp;#34;run&amp;#34; condition.</description></item><item><title>pypyr release v4.3.0</title><link>https://pypyr.io/updates/releases/v4.3.0/</link><pubDate>Thu, 12 Nov 2020 20:36:36 +0000</pubDate><guid>https://pypyr.io/updates/releases/v4.3.0/</guid><description>pypyr release v4.3.0 permalink streamlined api main() entry-point permalinkRelease Date: 2020-11-12T20:36:36Z
This one is for all the API consumers! The new API entry-point is likely to be useful to anyone who wants to pass regular Python objects directly to pypyr, rather than have to mediate through a string-based cli-orientated context_parser first.
Streamline main entrypoint API. close #201. main() allows consumer to set pype loader, rather than having to drop further down into api to load_and_run_pipeline() new main_with_context() allows you to use a standard Python dict to initialize context and bypass the pipeline&amp;rsquo;s context_parser entirely.</description></item><item><title>pypyr release v4.2.0</title><link>https://pypyr.io/updates/releases/v4.2.0/</link><pubDate>Fri, 30 Oct 2020 00:27:59 +0000</pubDate><guid>https://pypyr.io/updates/releases/v4.2.0/</guid><description>pypyr release v4.2.0 permalink flat &amp;amp; recursive format, !jsonify, parsejson permalinkRelease Date: 2020-10-30T00:27:59Z
python 3.9 compatibility officially confirmed &amp;amp; enforced in CI. All good. Woo! ðŸŽ‰ New Flat ff and Recursive rf formatting specifiers. #195 Check recursive vs flat format expressions for full documentation. Maintain backwards compatibility for all current formatting functionality. The get_formatted_string, get_formatted_iterable &amp;amp; get_processed_string methods on Context() are now all deprecated. Use get_formatted_value instead. All of the deprecated functions will keep on working as before, but will print a WARN to the output.</description></item><item><title>pypyr.steps.jsonparse</title><link>https://pypyr.io/docs/steps/jsonparse/</link><pubDate>Mon, 26 Oct 2020 13:12:12 +0000</pubDate><guid>https://pypyr.io/docs/steps/jsonparse/</guid><description>pypyr.steps.jsonparse permalink parse json string into context object permalinkParse an input json string into the pypyr context as an object. This allows you to work with the deserialized objects from the json string like you would normally work with any data structures in the pypyr context - so you can use all the usual context handling functionality to set, edit &amp;amp; manipulate context keys and values.
This step requires the jsonParse key in the pypyr context:</description></item><item><title>new site launch with hugo</title><link>https://pypyr.io/updates/news/new-site-launch-hugo/</link><pubDate>Wed, 09 Sep 2020 13:44:57 +0100</pubDate><guid>https://pypyr.io/updates/news/new-site-launch-hugo/</guid><description>new technical documentation website permalinkðŸ“£ pypyr.io has a shiny new website. ðŸ“£
You&amp;rsquo;re reading it right now! Hopefully, your eyeballs are relaaaaxing with that delicious dark mode.
If you want to learn more about the journey to create this site, check out technical documentation built with hugo.</description></item><item><title>technical documentation built with hugo</title><link>https://pypyr.io/docs/thank-you/built-with-hugo/</link><pubDate>Mon, 07 Sep 2020 12:09:06 +0100</pubDate><guid>https://pypyr.io/docs/thank-you/built-with-hugo/</guid><description>technical documentation built with hugo permalinkThis website builds on top of the popular open source static site generator hugo.
I was hoping to create a friendly &amp;amp; helpful product site more so than just a cut-and-dry API technical information sheet. There are many great no- to low-code frameworks for publishing technical documentation out there, but generally these are more constrained when you need to step outside of the prescribed boundaries of the given layouts.</description></item><item><title>release v4.1.0</title><link>https://pypyr.io/updates/releases/v4.1.0/</link><pubDate>Sun, 30 Aug 2020 19:04:37 +0000</pubDate><guid>https://pypyr.io/updates/releases/v4.1.0/</guid><description>pypyr release v4.1.0 permalink step description (skipping) when skipping. permalinkRelease Date: 2020-08-30T19:04:37Z
Better description output - add (skipping) to output if the step is not running because run is False or skip is True. Ref #158. First release published from shiny new GitHub Action CI/CD! Add License to wheel published to pypi You can find pypyr release v4.1.0 on github, where you can click through to associated Issues, Pull Requests and Users.</description></item><item><title>pypyr-aws release v1.1.2</title><link>https://pypyr.io/updates/releases/pypyr-aws/v1.1.2/</link><pubDate>Sun, 30 Aug 2020 14:39:52 +0000</pubDate><guid>https://pypyr.io/updates/releases/pypyr-aws/v1.1.2/</guid><description>pypyr-aws release v1.1.2 permalink updated readme permalinkRelease Date: 2020-08-30T14:39:52Z
no functional change updated README for pypi to point to new https://pypyr.io/docs/plugins/aws/ documentation site remove shippable ci add GitHub Actions ci fix linting errors You can find pypyr-aws release v1.1.2 on github, where you can click through to associated Issues, Pull Requests and Users.
Released by yaythomas.</description></item><item><title>pypyr-slack release v1.1.1</title><link>https://pypyr.io/updates/releases/pypyr-slack/v1.1.1/</link><pubDate>Sun, 30 Aug 2020 13:25:13 +0000</pubDate><guid>https://pypyr.io/updates/releases/pypyr-slack/v1.1.1/</guid><description>pypyr-slack release v1.1.1 permalink slack api 2: no functional change permalinkRelease Date: 2020-08-30T13:25:13Z
no functional change update slack api to 2.x update pypyr docs to point to new https://pypyr.io website pypi author change move from shippable to GitHub Actions. You can find pypyr-slack release v1.1.1 on github, where you can click through to associated Issues, Pull Requests and Users.
Released by yaythomas.</description></item><item><title>pypyraws.steps.ecswaitprep</title><link>https://pypyr.io/docs/plugins/aws/steps/ecswaitprep/</link><pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/steps/ecswaitprep/</guid><description>pypyraws.steps.ecswaitprep permalink wait for ecs state changes permalinkRun me after an ecs task run or stop to prepare an ecs waiter.
Prepares the awsWaitIn context key for pypyraws.steps.wait.
Available ecs waiters are:
ServicesInactive ServicesStable TasksRunning TasksStopped Full details here: http://boto3.readthedocs.io/en/latest/reference/services/ecs.html#waiters
Use this step after any of the following ecs client methods if you want to use one of the ecs waiters to wait for a specific state:</description></item><item><title>pypyraws.steps.s3fetchjson</title><link>https://pypyr.io/docs/plugins/aws/steps/s3fetchjson/</link><pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/steps/s3fetchjson/</guid><description>pypyraws.steps.s3fetchjson permalinkFetch a json file from s3 and put the json values into context.
input permalinkRequired input context is:
s3Fetch:clientArgs:# optionalarg1Name:arg1ValuemethodArgs:# mandatoryBucket:&amp;#39;{bucket}&amp;#39;Key:arb.jsonkey:&amp;#39;destination pypyr context key&amp;#39;# optional clientArgs go to the aws s3 client constructor. These are optional. methodArgs go to the the s3 get_object call. The minimum required values are: Bucket Key key writes fetched json to this context key. If not specified, json writes directly to context root.</description></item><item><title>pypyraws.steps.s3fetchyaml</title><link>https://pypyr.io/docs/plugins/aws/steps/s3fetchyaml/</link><pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/steps/s3fetchyaml/</guid><description>pypyraws.steps.s3fetchyaml permalinkFetch a yaml file from s3 and put the yaml structure into context.
input permalinkRequired input context is:
s3Fetch:clientArgs:# optionalarg1Name:arg1ValuemethodArgs:# mandatoryBucket:&amp;#39;{bucket}&amp;#39;Key:arb.yamlkey:&amp;#39;destination pypyr context key&amp;#39;# optional clientArgs go to the aws s3 client constructor. These are optional. methodArgs go to the the s3 get_object call. The minimum required values are: Bucket Key key writes fetched yaml to this context key. If not specified, yaml writes directly to context root.</description></item><item><title>pypyrslack.steps.send</title><link>https://pypyr.io/docs/plugins/slack/steps/send/</link><pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/slack/steps/send/</guid><description>pypyrslack.steps.send permalinkSend a message to slack.
input permalinkRequires the following context items:
slackToken your slack api token. Keep this secure. slackChannel send to this slack channel (include # in front) slackText the body of your message. Use your usual slack formatting chars. substitutions permalinkFor all inputs you can use substitution tokens, aka string interpolation. This substitutes anything between curly braces with the context value for that key.</description></item><item><title>pypyraws.steps.wait</title><link>https://pypyr.io/docs/plugins/aws/steps/wait/</link><pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/steps/wait/</guid><description>pypyraws.steps.wait permalink wait for aws state changes permalinkWait for things in AWS to complete before continuing pipeline.
Run any low-level boto3 client wait() from get_waiter.
Waiters use a client&amp;rsquo;s service operations to poll the status of an AWS resource and suspend execution until the AWS resource reaches the state that the waiter is polling for or a failure occurs while polling.
http://boto3.readthedocs.io/en/latest/guide/clients.html#waiters
input permalinkThe input context requires:
awsWaitIn:serviceName: &amp;#39;service name&amp;#39; # Available services here:http://boto3.</description></item><item><title>pypyraws.steps.waitfor</title><link>https://pypyr.io/docs/plugins/aws/steps/waitfor/</link><pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/steps/waitfor/</guid><description>pypyraws.steps.waitfor permalink custom waiter for aws state changes permalinkCustom waiter for any aws client operation. Where pypyraws.steps.wait uses the official AWS waiters from the low-level client api, this step allows you to execute any aws low-level client method and wait for a specified field in the response to become the value you want it to be.
AWS does not have waiters for all state changes. Use this to create your own waiter for any property state change.</description></item><item><title>authentication</title><link>https://pypyr.io/docs/plugins/aws/authentication/</link><pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/authentication/</guid><description>aws authentication permalink configuring credentials permalinkpypyr-aws pretty much just uses the underlying boto3 authentication mechanisms. More info here: http://boto3.readthedocs.io/en/latest/guide/configuration.html
This means any of the following will work. The authentication settings lookup order is as follows:
IAM credentials when inside AWS permalinkIf you are running inside of AWS - on EC2 or inside an ECS container, it will automatically use IAM role credentials if it does not find credentials in any of the other places listed below.</description></item><item><title>authentication</title><link>https://pypyr.io/docs/plugins/slack/authentication/</link><pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/slack/authentication/</guid><description>slack authentication permalink Get slack api token permalinkTo authenticate against your slack, you need to create an api key. There&amp;rsquo;re various ways of going about this, using legacy tokens, test tokens or a bot.
I generally create a bot. Given you&amp;rsquo;re likely to use it just to send notifications to slack, rather than consume events from slack, it&amp;rsquo;s a pretty simple setup just to get your api key.
Remember to invite and add the bot you create to the slack channel(s) to which you want to post.</description></item><item><title>pypyraws.steps.client</title><link>https://pypyr.io/docs/plugins/aws/steps/client/</link><pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/steps/client/</guid><description>pypyraws.steps.client permalink use any low-level aws service client permalinkThis step provides an easy way of getting at the low-level AWS api from the pypyr pipeline runner. So in short, pretty much anything you can do with the AWS api you got it as the Big O might have said.
This step lets you specify the service name and the service method you want to execute dynamically. You can also control the service header arguments and the method arguments themselves.</description></item><item><title>substitutions</title><link>https://pypyr.io/docs/plugins/aws/substitutions/</link><pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/plugins/aws/substitutions/</guid><description>substitutions permalinkYou can use substitution tokens, aka string interpolation, where specified for context items. This substitutes anything between {curly braces} with the context value for that key.
This also works where you have dictionaries/lists inside dictionaries/lists. For example, if your context looked like this:
bucketValue:the.bucketkeyValue:dont.kickmoreArbText:wildawsClientIn:serviceName:s3methodName:get_objectmethodArgs:Bucket:&amp;#39;{bucketValue}&amp;#39;Key:&amp;#39;{keyValue}&amp;#39;This will run s3 get_object to retrieve file dont.kick from the.bucket.
Bucket: '{bucketValue}' becomes Bucket: the.bucket Key: '{keyValue}' becomes Key: dont.kick In json &amp;amp; yaml, curlies need to be inside quotes to make sure they parse as strings.</description></item><item><title>release v4.0.0</title><link>https://pypyr.io/updates/releases/v4.0.0/</link><pubDate>Mon, 17 Aug 2020 19:27:51 +0000</pubDate><guid>https://pypyr.io/updates/releases/v4.0.0/</guid><description>pypyr release v4.0.0 permalink Stop in failure handlers. in context cleanup default. permalinkRelease Date: 2020-08-17T19:27:51Z
BREAKING CHANGE: final deprecation of in args scope persisting after step execution. For full discussion please see #177. Preview functionality where setting environment variable $PYPYR_IN_CLEAN = 1 is now the default. You can remove the $PYPYR_IN_CLEAN variable from this release onwards. Henceforth pypyr removes in args from context after step completes. If you want to persist values in context beyond the current step, use pypyr.</description></item><item><title>pypyr.steps.contextcopy</title><link>https://pypyr.io/docs/steps/contextcopy/</link><pubDate>Sat, 15 Aug 2020 20:28:42 +0100</pubDate><guid>https://pypyr.io/docs/steps/contextcopy/</guid><description>pypyr.steps.contextcopy permalink copy values &amp;amp; structures from one part of context to another permalinkCopies context values from already existing context values.
This is handy if you need to prepare certain keys in context where a next step might need a specific key. If you already have the value in context, you can create a new key (or update existing key) with that value.
contextcopy and contextsetf overwrite existing keys. If you want to merge new values into an existing destination hierarchy, use contextmerge instead.</description></item><item><title>release v3.2.2</title><link>https://pypyr.io/updates/releases/v3.2.2/</link><pubDate>Thu, 13 Aug 2020 19:34:08 +0000</pubDate><guid>https://pypyr.io/updates/releases/v3.2.2/</guid><description>pypyr release v3.2.2 permalink line + col no., repo rename, readme updates. permalinkRelease Date: 2020-08-13T19:34:08Z
Line + Column Number count from 1 not 0. fix #151 update README to point at new website pypyr.io. update CONTRIBUTING to point at new website. update documentation and pypi setup with new repo name. You can find pypyr release v3.2.2 on github, where you can click through to associated Issues, Pull Requests and Users.</description></item><item><title>pypyr.steps.assert</title><link>https://pypyr.io/docs/steps/assert/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/steps/assert/</guid><description>pypyr.steps.assert permalink stop pipeline execution if condition false permalinkAssert that something is True or equal to something else. The step raises an exception of type AssertionError if the assertion fails.
You can express an assert in three different ways:
- name:pypyr.steps.assertcomment:evaluates `assert` as truthyin:assert:&amp;#39;{evaluateMe}&amp;#39;- name:pypyr.steps.assertcomment:evaluate `this` as truthyin:assert:this:&amp;#39;{evaluateMe}&amp;#39;- name:pypyr.steps.assertcomment:assert that two things are equalin:assert:this:&amp;#39;{complexThing1}&amp;#39;equals:&amp;#39;{complexThing2}&amp;#39;The first two mostly do the same thing, so use whichever pleases your eye more. The only difference is in how pypyr processes mappings for truthy.</description></item><item><title>built-in pipelines</title><link>https://pypyr.io/docs/pipelines/builtin-pipelines/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/pipelines/builtin-pipelines/</guid><description>Built-in pipelines permalinkpypyr comes with with some basic pipelines out of the box. These don&amp;rsquo;t do much, nor can they: the whole idea is for you to write your own awesome pipelines because it so so easy!
pipeline description how to run donothing Does what it says. Nothing. pypyr donothing echo Echos context value echoMe to output. pypyr echo text goes here pypyrversion Prints the python cli version number.</description></item><item><title>pypyr.steps.call</title><link>https://pypyr.io/docs/steps/call/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/steps/call/</guid><description>pypyr.steps.call permalink call another step in pipeline permalinkCall (invoke) another step-group in the same pipeline. Once the called group(s) are complete, pypyr continues processing from the point where you initiated the call.
If you want to jump to a different step-group and ignore the rest of the step-group you&amp;rsquo;re in, use pypyr.steps.jump instead.
input permalinkcall expects a context item call. It can take one of two forms:
- name:pypyr.steps.callcomment:simple string means just call the step-group named &amp;#34;callme&amp;#34;in:call:callme- name:pypyr.</description></item><item><title>custom context parser</title><link>https://pypyr.io/docs/api/context-parser/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/context-parser/</guid><description>create a custom context parser permalink parse custom cli arguments permalinkA context_parser parses the pypyr cli input arguments. Simply put, this is all the positional arguments after the pipeline-name in the cli.
$ pypyr pipelinename this is the args input In this example, ['this', 'is', 'the', 'args', 'input'] will go to the pipeline&amp;rsquo;s context parser as input.
Generally, a context_parser is likely to take the input args list and create a dict with it somehow.</description></item><item><title>contribute to pypyr</title><link>https://pypyr.io/docs/contributing/contribute-to-pypyr/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/contributing/contribute-to-pypyr/</guid><description>contribute to pypyr permalinkpypyr is open source. Your contributions are most welcome.
Feel free to join the pypyr discussion on the pypyr community discussion forum.
bugs permalinkWell, you know. No one&amp;rsquo;s perfect. Feel free to create an issue.
contribute to the core cli permalinkThe usual jazz - create an issue, fork, code, test, PR. It might be an idea to discuss your idea on the discussion forum or via the Issues list first before you go off and write a huge amount of code - you never know, something might already be in the works, or maybe it&amp;rsquo;s not quite right for the core-cli (you&amp;rsquo;re still welcome to fork and go wild regardless, of course, it just mightn&amp;rsquo;t get merged back in here).</description></item><item><title>custom args</title><link>https://pypyr.io/docs/cli/custom-args/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/cli/custom-args/</guid><description>pass custom optional arguments from the cli permalinkYou can pass your own arguments to your pipelines from the cli without writing any code. You can decide per pipeline what style of arguments work better for that specific pipeline, for example key-value pairs, or a single string, or boolean switches.
See context parsers for more information on how to pass your own arguments to a pipeline and how to use those runtime values in the pipeline.</description></item><item><title>custom pype loader</title><link>https://pypyr.io/docs/api/pipeline-loader/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/pipeline-loader/</guid><description>create a custom pipeline loader permalink load pipeline not on the local filesystem permalinkA pype loader is responsible for loading a pipeline.
The default pype loader is pypyr.pypeloaders.fileloader.
This default loader loads pipelines from the local file-system, following the usual pypyr pipeline look-up sequence.
If you want to load pipelines from somewhere else, like maybe a shared pipeline library, or implement your own caching, or maybe if you want to load a pipeline from something like s3 or consul, you can roll your own pype loader.</description></item><item><title>developer's guide for pypyr</title><link>https://pypyr.io/docs/contributing/developers-guide/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/contributing/developers-guide/</guid><description>developer&amp;rsquo;s guide permalink coding style permalinkYou&amp;rsquo;ve read pep8? pypyr uses flake8 as a quality gate during ci.
testing without worrying about dependencies permalinkRun tox to test the packaging cycle inside a tox virtual env, plus run all tests:
# run tests &amp;amp; flake 8 linter $ tox ops/build # run tests, flake 8 linter, test packaging &amp;amp; validate README.rst $ tox ops/build package This of course assumes you have tox installed in your current active Python environment.</description></item><item><title>pypyr.steps.echo</title><link>https://pypyr.io/docs/steps/echo/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/steps/echo/</guid><description>pypyr.steps.echo permalink write dynamic values to console output stdout permalinkEcho (i.e print) the context value echoMe to the output.
For example, if you had a pipeline like this:
# ./mypipeline.yamlcontext_parser:pypyr.parser.keyvaluepairssteps:- name:pypyr.steps.echoYou can run:
$ pypyr mypipeline &amp;#34;echoMe=Ceci n&amp;#39;est pas une pipe&amp;#34; Alternatively, if you had a pipeline like this:
# ./look-ma-no-params.yamlsteps:- name:pypyr.steps.echocomment:Output echoMein:echoMe:Ceci n&amp;#39;est pas une pipeYou can run:
$ pypyr look-ma-no-params Supports string substitutions.
write complex objects to output permalinkecho will serialize complex objects like dict or list to stdout for you.</description></item><item><title>privacy notice</title><link>https://pypyr.io/legal/privacy-notice/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/legal/privacy-notice/</guid><description>privacy notice permalink cookie notice permalinkThis website uses Google Analytics. This is to see which pages are popular, and get a better understanding of which features you use most &amp;amp; where we can improve documentation. Without it, we have no idea which browsing paths you are taking to find what you are looking for, how much time it takes for you to find what you need and as such whether the documentation is actually useful to you or not.</description></item><item><title>run pipeline api</title><link>https://pypyr.io/docs/api/run-pipeline/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/run-pipeline/</guid><description>run a pipeline from the api permalinkYou can run a pypyr automation pipeline programmatically from your own code using the python api.
# ./pipeline-dir/my-pipe.yamlcontext_parser:pypyr.parser.keyvaluepairssteps:- name:pypyr.steps.echoin:echoMe:piper {arbkey} that {anotherkey} again- name:pypyr.steps.contextsetfin:contextSetf:myoutput:I was set in the pipeline!input_values:- &amp;#39;{arbkey}&amp;#39;- &amp;#39;{anotherkey}&amp;#39;some_nesting:down_level:arb_number:123arb_bool:FalseRun this pipeline from the cli like this:
term $ pypyr pipeline-dir/my-pipe arbkey=pipe anotherkey=song piper pipe that song again $ You can run this same pipeline programmatically like this:</description></item><item><title>custom step</title><link>https://pypyr.io/docs/api/step/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://pypyr.io/docs/api/step/</guid><description>create a custom step permalinkIf you can&amp;rsquo;t find a ready-made step that quite scratches your particular itch, don&amp;rsquo;t hesitate to code your own step - it&amp;rsquo;s easy, and very much the philosophy of pypyr that if you can write a quick couple of lines of python rather than contort your pipeline with clumsy step sequences, then do so! I know some frameworks don&amp;rsquo;t really encourage you to stray outside the prescribed features, but not so pypyr - your custom steps are first-class citizens of the pypyrverse.</description></item><item><title>dependencies</title><link>https://pypyr.io/docs/thank-you/dependencies/</link><pubDate>Mon, 10 Aug 2020 14:18:44 +0100</pubDate><guid>https://pypyr.io/docs/thank-you/dependencies/</guid><description>dependencies permalinkpypyr is fortunate to stand on the shoulders of giants in the shape of the excellent open-source software that makes everything that much easier. With great thanks &amp;amp; gratitude to:
dependency license description bumpversion MIT Release semantic version increments. check-manifest MIT PyPI integrity checks. coverage Apache 2.0 Code test coverage analysis. docutils BSD Documentation processing for setup.</description></item><item><title>press kit</title><link>https://pypyr.io/press-kit/</link><pubDate>Sat, 08 Aug 2020 20:06:45 +0100</pubDate><guid>https://pypyr.io/press-kit/</guid><description>press kit permalink what is pypyr? permalinkpypyr is an open source task-runner for automation pipelines. pypyr lets you script sequential tasks in a simple yaml format with conditional execution, loops, error handling and retries for any step in your pipeline.
Like a turbo-charged shell script, but less finicky. Less tricky than a makefile.
You can run loops, conditionally execute steps based on conditions you specify, wait for status changes before continuing, break on failure conditions or swallow errors.</description></item><item><title>copyright &amp; licensing</title><link>https://pypyr.io/legal/licensing/</link><pubDate>Sat, 08 Aug 2020 15:04:34 +0100</pubDate><guid>https://pypyr.io/legal/licensing/</guid><description>copyright &amp;amp; licensing permalinkCode and documentation copyright 2017 - 2021, the pypyr contributors.
pypyr code is licensed under the Apache 2.0 license.
pypyr is free and open source software.</description></item><item><title>while loop decorator</title><link>https://pypyr.io/docs/decorators/while/</link><pubDate>Tue, 14 Jul 2020 13:09:24 +0100</pubDate><guid>https://pypyr.io/docs/decorators/while/</guid><description>while permalink repeat step(s) in while loop permalinkRepeat step until stop is True, or until you reach a configurable maximum iterations. You have to specify at least one of either max or stop.
If you specify both max and stop, the loop exits when stop is True as long as it&amp;rsquo;s still under max iterations.
max will exit the loop even if stop is still False. If you want to error and stop processing when max exhausts set errorOnMax to True.</description></item><item><title>skip decorator</title><link>https://pypyr.io/docs/decorators/skip/</link><pubDate>Tue, 14 Jul 2020 11:38:26 +0100</pubDate><guid>https://pypyr.io/docs/decorators/skip/</guid><description>skip permalink selectively skip step permalinkSkip this step if True, run step if False. Evaluates after the run decorator. This means that if run is False, the step will never run, regardless of skip.
Default is False. This means by default pypyr will not skip a step.
If this looks like it&amp;rsquo;s merely the inverse of run, that&amp;rsquo;s because it is. Use whichever suits your pipeline better, or combine run and skip in the same pipeline to toggle at runtime which steps you want to execute.</description></item><item><title>run decorator</title><link>https://pypyr.io/docs/decorators/run/</link><pubDate>Tue, 14 Jul 2020 11:02:07 +0100</pubDate><guid>https://pypyr.io/docs/decorators/run/</guid><description>run permalink selectively run step permalinkRuns this step if True, skips step if False.
Default is True. The means by default pypyr will run a step unless you tell it otherwise.
You&amp;rsquo;ll almost always use run with substitutions, so you set the value at run-time from context.
set run with substitution expressions permalinkYou can use truthy expressions with run, skip and swallow. This means you can selectively run a step depending on if an object is not null and evaluates truthy.</description></item><item><title>retry decorator</title><link>https://pypyr.io/docs/decorators/retry/</link><pubDate>Mon, 13 Jul 2020 13:37:06 +0100</pubDate><guid>https://pypyr.io/docs/decorators/retry/</guid><description>retry permalink automatic retries permalinkRetries the step until it succeeds. If you do not set retry, pypyr will not retry the step automatically. When you do set retry, pypyr will retry whatever step it is without you having to do anything else.
The retry iteration counter is retryCounter. You can use this as usual for any context value in a formatting string expression as {retryCounter}.
These are all the available configuration parameters for retry:</description></item><item><title>swallow decorator</title><link>https://pypyr.io/docs/decorators/swallow/</link><pubDate>Sat, 11 Jul 2020 22:04:10 +0100</pubDate><guid>https://pypyr.io/docs/decorators/swallow/</guid><description>swallow permalink ignore pipeline step error permalinkIf True, catch any errors raised by the step and continue to the next step. pypyr logs the error both the output and to runErrors in context, so you&amp;rsquo;ll know what happened, but processing continues. When you set swallow to True, pypyr will NOT go to the step-group&amp;rsquo;s failure handler.
You could think of this as on error resume next for your pipeline.</description></item><item><title>onError decorator</title><link>https://pypyr.io/docs/decorators/onerror/</link><pubDate>Sat, 11 Jul 2020 21:42:31 +0100</pubDate><guid>https://pypyr.io/docs/decorators/onerror/</guid><description>onError permalink add custom data to exception permalinkProvide custom error information if the step raises an exception. This lets you add extra information to the error itself.
If this step errors, write the contents of onError to runErrors[n].customError in context. Steps inside a failure handler then can use this information. Alternatively, subsequent steps can also use this information, assuming you&amp;rsquo;ve got a swallow somewhere in the call chain.
onError can be a simple string, or your your own dict, or any given object.</description></item><item><title>description decorator</title><link>https://pypyr.io/docs/decorators/description/</link><pubDate>Sat, 11 Jul 2020 20:35:07 +0100</pubDate><guid>https://pypyr.io/docs/decorators/description/</guid><description>description permalink provide step status output permalinkdescription is text that prints to the output when the pipeline runs. This is useful to provide operators with visibility of pipeline progress, especially where steps themselves do not provide any output.
The description outputs at NOTIFY - 25 level. This means you will see it by default. If you want to suppress description output, run pypyr with --log higher than 25.
If you are looking to annotate your pipeline in a way that does not print to runtime output use comment instead.</description></item><item><title>comment decorator</title><link>https://pypyr.io/docs/decorators/comment/</link><pubDate>Sat, 11 Jul 2020 20:13:51 +0100</pubDate><guid>https://pypyr.io/docs/decorators/comment/</guid><description>comment permalink comment your pipeline code permalinkSimilar to code comments, comment is for pipeline authors to annotate a pipeline step for the usual reasons. Like remembering why on earth you did something in a certain way two weeks later.
comment does not output at run-time ever. If you&amp;rsquo;re looking to add descriptive text that prints to output for pipeline consumer visibility, use description instead.
- name:pypyr.steps.contextsetfcomment:this comment is for pipeline authors.</description></item><item><title>in decorator</title><link>https://pypyr.io/docs/decorators/in/</link><pubDate>Sat, 11 Jul 2020 12:56:32 +0100</pubDate><guid>https://pypyr.io/docs/decorators/in/</guid><description>in permalink add input arguments to step context permalinkin sets the input arguments for a step. pypyr adds anything in in to the context so that the decorated step can use these key-value pairs.
in is a mapping, also known as a dict {}. You can use complex, nested structures. pypyr will honor the data types of the yaml values you set in your pipeline.
# arbitrarily complex nested input args, # with different data types, # just to make a point.</description></item><item><title>foreach loop decorator</title><link>https://pypyr.io/docs/decorators/foreach/</link><pubDate>Fri, 10 Jul 2020 19:07:51 +0100</pubDate><guid>https://pypyr.io/docs/decorators/foreach/</guid><description>foreach permalink repeat step for each item in list permalinkRun the step once for each item in the list.
The iterator is context['i']. If you want to use the iterator value in your step with a substitution expression, you&amp;rsquo;d use {i}.
foreach takes any iterable. In your pipeline yaml, you can specify this as a list [] in two ways:
foreach:[item 1, item 2, item 3]or
foreach:- item 1- item 2- item 3 loop static input list permalinkThe foreach input here is a standard list.</description></item><item><title>pypyr.parser.yamlfile</title><link>https://pypyr.io/docs/context-parsers/yamlfile/</link><pubDate>Thu, 09 Jul 2020 17:42:16 +0100</pubDate><guid>https://pypyr.io/docs/context-parsers/yamlfile/</guid><description>pypyr.parser.yamlfile permalink read yaml file into context permalinkOpens a yaml file from the input path and use it to initialize the pypyr context dictionary. Strongly typed values in the source yaml will translate into the pipeline context with the correct type. This lets you initialize pipeline context from a yaml file.
The input path can be relative or absolute. Relative paths are relative to the current working directory.
example permalinkGiven a yaml file like this, saved as .</description></item><item><title>pypyr.parser.string</title><link>https://pypyr.io/docs/context-parsers/string/</link><pubDate>Thu, 09 Jul 2020 16:52:56 +0100</pubDate><guid>https://pypyr.io/docs/context-parsers/string/</guid><description>pypyr.parser.string permalink put all cli input args into a single string permalinkTakes any arbitrary input from the cli input args and concatenate into a single string argString to initialize context.
If you have multiple sequential literal spaces right next to each other, escape these with single or double quotes.
Given a pipeline like this, arbitrarily saved as ./string-parser.yaml:
# ./string-parser.yamlcontext_parser:pypyr.parser.stringsteps:- pypyr.steps.debug# prints at log level &amp;lt;=20- name:pypyr.steps.echocomment:use argString in format expressionin:echoMe:&amp;#34;this came from the cli: {argString}&amp;#34;You can then pass any given string, including nothing, from the cli to the pipeline to initialize context:</description></item><item><title>pypyr.parser.list</title><link>https://pypyr.io/docs/context-parsers/list/</link><pubDate>Thu, 09 Jul 2020 16:34:56 +0100</pubDate><guid>https://pypyr.io/docs/context-parsers/list/</guid><description>pypyr.parser.list permalink parse cli input args into list permalinkAppend each input argument into a list argList to initialize context.
Escape literal spaces with single or double quotes.
Given a pipeline like this, arbitrarily saved as ./list-parser.yaml:
# ./list-parser.yamlcontext_parser:pypyr.parser.liststeps:- pypyr.steps.debug# prints at log level &amp;lt;=20- name:pypyr.steps.echocomment:the args passed into the pypyr with list parser end up as a list in context under key argListin:echoMe:&amp;#34;the 2nd thing on the input list is: {argList[1]}&amp;#34;Each argument you pass via the cli will now be in the argList list:</description></item><item><title>pypyr.parser.keyvaluepairs</title><link>https://pypyr.io/docs/context-parsers/keyvaluepairs/</link><pubDate>Thu, 09 Jul 2020 12:26:36 +0100</pubDate><guid>https://pypyr.io/docs/context-parsers/keyvaluepairs/</guid><description>pypyr.parser.keyvaluepairs permalink pass key value pairs from cli to pipeline permalinkTakes key=value pair string from cli arg input and initialize context with a dictionary where each pair becomes a dictionary element.
Escape literal spaces with single or double quotes.
Given a pipeline like this, arbitrarily saved as ./keyvaluepairs-parser.yaml:
# ./keyvaluepairs-parser.yamlcontext_parser:pypyr.parser.keyvaluepairssteps:- pypyr.steps.debug# prints at log level &amp;lt;=20You can then pass key-value pairs from the cli to the pipeline to initialize context.</description></item><item><title>pypyr.parser.keys</title><link>https://pypyr.io/docs/context-parsers/keys/</link><pubDate>Thu, 09 Jul 2020 12:06:01 +0100</pubDate><guid>https://pypyr.io/docs/context-parsers/keys/</guid><description> pypyr.parser.keys permalink custom boolean switches from the cli permalinkFor each input argument, initialize context with a dictionary where each argument becomes the key, with value set to True.
Escape literal spaces with single or double quotes.
Given a pipeline like this, arbitrarily saved as ./keys-parser.yaml:
# ./keys-parser.yamlcontext_parser:pypyr.parser.keyssteps:- pypyr.steps.debug# prints at log level &amp;lt;=20Running the pipeline with different inputs:
$ pypyr keys-parser --log 20 {} $ pypyr keys-parser a b c --log 20 {&amp;#39;a&amp;#39;: True, &amp;#39;b&amp;#39;: True, &amp;#39;c&amp;#39;: True} $ pypyr keys-parser &amp;#34;a with space&amp;#34; &amp;#39; b&amp;#39; c --log 20 {&amp;#39; b&amp;#39;: True, &amp;#39;a with space&amp;#39;: True, &amp;#39;c&amp;#39;: True}</description></item><item><title>pypyr.parser.jsonfile</title><link>https://pypyr.io/docs/context-parsers/jsonfile/</link><pubDate>Thu, 09 Jul 2020 11:19:55 +0100</pubDate><guid>https://pypyr.io/docs/context-parsers/jsonfile/</guid><description>pypyr.parser.jsonfile permalink read json file into context permalinkTakes a path from the cli input argument, and read the json file at that path into context. Strongly typed values in the source json will translate into the pipeline context. This lets you initialize pipeline context from a json file.
The input path can be relative or absolute. Relative paths are relative to the current working directory.
example permalinkGiven a json file like this, saved as .</description></item><item><title>pypyr.parser.json</title><link>https://pypyr.io/docs/context-parsers/json/</link><pubDate>Wed, 08 Jul 2020 19:18:15 +0100</pubDate><guid>https://pypyr.io/docs/context-parsers/json/</guid><description>pypyr.parser.json permalink parse json input string from cli permalinkTakes a json string from the cli argument input, parses it into a type-safe json object, and puts the object into the pypyr context.
pypyr honors the input json data types. In other words, bools are bools, numbers are numbers, nulls are nulls.
example permalinkGiven a pipeline like this, arbitrarily saved as ./json-parser.yaml:
# ./json-parser.yamlcontext_parser:pypyr.parser.jsonsteps:# echoMe will be set in the input json str- pypyr.</description></item><item><title>pypyr.parser.dict</title><link>https://pypyr.io/docs/context-parsers/dict/</link><pubDate>Wed, 08 Jul 2020 18:44:23 +0100</pubDate><guid>https://pypyr.io/docs/context-parsers/dict/</guid><description>pypyr.parser.dict permalink create a dict from key=value pair string permalinkTakes a key=value pair string and returns a dictionary (aka a map) where each pair becomes a dictionary element inside a dict with name argDict.
Escape literal spaces with single or double quotes.
example permalink$ pypyr pipelinename param1=value1 param2=&amp;#34;value 2&amp;#34; param3=value3 This will create a context dictionary like this:
{&amp;#39;argDict&amp;#39;: {&amp;#39;param1&amp;#39;: &amp;#39;value1&amp;#39;, &amp;#39;param2&amp;#39;: &amp;#39;value 2&amp;#39;, &amp;#39;param3&amp;#39;: &amp;#39;value3&amp;#39;}} Or to put in in yaml terms:</description></item><item><title>pypyr.steps.tar</title><link>https://pypyr.io/docs/steps/tar/</link><pubDate>Tue, 07 Jul 2020 17:42:21 +0100</pubDate><guid>https://pypyr.io/docs/steps/tar/</guid><description>pypyr.steps.tar permalink archive &amp;amp; extract tar files with compression permalinkArchive and extract tars with or without compression.
- name:pypyr.steps.tarcomment:extract &amp;amp; archive tarin:tar:extract:- in:/path/my.tarout:/out/patharchive:- in:/dir/to/archiveout:/out/destination.tarformat:&amp;#39;&amp;#39;# optional. &amp;#39;&amp;#39; | gz | bz2 | xzEither extract or archive should exist, or both. But not neither.
Optionally, you can also specify the tar compression format with format. Available options for format:
'' - no compression gz - (gzip) bz2 - (bzip2) xz - (lzma) If you do not specify format, it defaults to xz (lzma).</description></item><item><title>pypyr.steps.stopstepgroup</title><link>https://pypyr.io/docs/steps/stopstepgroup/</link><pubDate>Tue, 07 Jul 2020 17:36:13 +0100</pubDate><guid>https://pypyr.io/docs/steps/stopstepgroup/</guid><description>pypyr.steps.stopstepgroup permalinkStop current step-group. Doesn&amp;rsquo;t run any success or failure handlers, it just stops the current step-group.
This is handy if you are using pypyr.steps.call or pypyr.steps.jump to run different step-groups, allowing you to stop just a child step-group but letting the calling parent step-group continue.
You can always use pypyr.steps.stopstepgroup as a simple step, because it doesn&amp;rsquo;t need any input context properties.
If you use a Stop step-group instruction inside a failure handler it will stop processing at that point AND not quit reporting failure.</description></item><item><title>pypyr.steps.stoppipeline</title><link>https://pypyr.io/docs/steps/stoppipeline/</link><pubDate>Tue, 07 Jul 2020 17:26:12 +0100</pubDate><guid>https://pypyr.io/docs/steps/stoppipeline/</guid><description>pypyr.steps.stoppipeline permalink stop current pipeline immediately permalinkStop current pipeline. Doesn&amp;rsquo;t run any success or failure handlers, it just stops the current pipeline.
This is handy if you are using pypyr.steps.pype to call child pipelines from a parent pipeline, allowing you to stop just a child pipeline but letting the parent pipeline continue.
You can always use pypyr.steps.stoppipeline as a simple step, because it doesn&amp;rsquo;t need any input context properties.</description></item><item><title>pypyr.steps.stop</title><link>https://pypyr.io/docs/steps/stop/</link><pubDate>Tue, 07 Jul 2020 17:19:20 +0100</pubDate><guid>https://pypyr.io/docs/steps/stop/</guid><description>pypyr.steps.stop permalink stop pypyr immediately permalinkStop all pypyr processing immediately. Doesn&amp;rsquo;t run any success or failure handlers, it just stops everything in its tracks, even when you&amp;rsquo;re nested in child pipelines or a step-group call-chain.
You can always use pypyr.steps.stop as a simple step, because it doesn&amp;rsquo;t need any input context properties.
If you use a Stop instruction inside a failure handler it will stop processing at that point AND not quit reporting failure.</description></item><item><title>pypyr.steps.shell</title><link>https://pypyr.io/docs/steps/shell/</link><pubDate>Tue, 07 Jul 2020 11:53:28 +0100</pubDate><guid>https://pypyr.io/docs/steps/shell/</guid><description>pypyr.steps.shell permalink run commands in default shell permalinkRuns the context value cmd in the default shell. On a sensible O/S, this is /bin/sh, or more recently zsh.
Do all the things you can&amp;rsquo;t do with cmd. cmd runs a program or executable, shell invokes the actual system shell. This means all your shell expressions are available, such as your favorite bashisms.
If you are just looking to run a command with arguments, you do not need to use shell, you can use cmd instead, which will incur less processing overhead.</description></item><item><title>pypyr.steps.safeshell</title><link>https://pypyr.io/docs/steps/safeshell/</link><pubDate>Tue, 07 Jul 2020 11:17:29 +0100</pubDate><guid>https://pypyr.io/docs/steps/safeshell/</guid><description> pypyr.steps.safeshell permalinkDeprecated alias for cmd.
Example pipeline yaml:
steps:- name:pypyr.steps.safeshellin:cmd:ls -a</description></item><item><title>pypyr.steps.nowutc</title><link>https://pypyr.io/docs/steps/nowutc/</link><pubDate>Tue, 07 Jul 2020 10:19:23 +0100</pubDate><guid>https://pypyr.io/docs/steps/nowutc/</guid><description>pypyr.steps.nowutc permalink get current utc timestamp permalinkWrites the current UTC date &amp;amp; time to context nowUtc.
If you want local or wall time, check out pypyr.steps.now instead.
If you run this step as a simple step (with no input nowUtcIn formatting), the default datetime format is ISO8601. For example: YYYY-MM-DDTHH:MM:SS.ffffff+00:00
You can use explicit format strings to control the datetime representation. For a full list of available formatting codes, check python date &amp;amp; time formatting</description></item><item><title>pypyr.steps.now</title><link>https://pypyr.io/docs/steps/now/</link><pubDate>Tue, 07 Jul 2020 10:14:55 +0100</pubDate><guid>https://pypyr.io/docs/steps/now/</guid><description>pypyr.steps.now permalink get current local timestamp permalinkWrites the current local date &amp;amp; time to context now. Local time is also known as wall time.
If you want UTC time, check out pypyr.steps.nowutc instead.
If you run this step as a simple step (with no input formatting specified in nowIn), the default datetime format is ISO8601. For example: YYYY-MM-DDTHH:MM:SS.ffffff+00:00.
You can use explicit format strings to control the datetime representation. For a full list of available formatting codes, check python date &amp;amp; time formatting</description></item><item><title>pypyr.steps.pypyrversion</title><link>https://pypyr.io/docs/steps/pypyrversion/</link><pubDate>Tue, 07 Jul 2020 10:10:38 +0100</pubDate><guid>https://pypyr.io/docs/steps/pypyrversion/</guid><description>pypyr.steps.pypyrversion permalink get current installed version permalinkOutput the same as:
pypyr --version This is an actual pipeline, though, so unlike --version, it&amp;rsquo;ll use the standard pypyr logging format.
Example pipeline yaml:
steps:- pypyr.steps.pypyrversionSince this step does not have any input context, you can always run it as a simple step by just specifying the step-name as a string.</description></item><item><title>pypyr.steps.pype</title><link>https://pypyr.io/docs/steps/pype/</link><pubDate>Mon, 06 Jul 2020 18:44:14 +0100</pubDate><guid>https://pypyr.io/docs/steps/pype/</guid><description>pypyr.steps.pype permalink call another pipeline from current pipeline permalinkRun another pipeline from this step. This allows pipelines to invoke other pipelines. Why pype? Because the pypyr can pipe that song again.
pype is handy if you want to split a larger, cumbersome pipeline into smaller units. This helps testing, in that you can test smaller units as separate pipelines without having to re-run the whole big all-encompassing parent pipeline each time.</description></item><item><title>pypyr.steps.py</title><link>https://pypyr.io/docs/steps/py/</link><pubDate>Mon, 06 Jul 2020 13:17:22 +0100</pubDate><guid>https://pypyr.io/docs/steps/py/</guid><description>pypyr.steps.py permalink run inline python permalinkExecutes the context value py as a dynamically interpreted python code block.
This is useful for adding inline Python code right in your pipeline.
You can use all the usual Python built-ins like len, abs and so forth. You can import standard libraries or your own custom modules &amp;amp; objects using the standard Python import syntax (e.g import x as y, from x import y).</description></item><item><title>pypyr.steps.pathcheck</title><link>https://pypyr.io/docs/steps/pathcheck/</link><pubDate>Mon, 06 Jul 2020 13:06:55 +0100</pubDate><guid>https://pypyr.io/docs/steps/pathcheck/</guid><description>pypyr.steps.pathcheck permalink check if paths exist permalinkCheck if a path exists on the filesystem. Supports globbing. A path can point to a file or a directory.
input permalinkThe pathCheck context key must exist.
- name:pypyr.steps.pathcheckin:pathCheck:./do/i/exist.arb# single literal path- name:pypyr.steps.pathcheckin:pathCheck:./**/*.py# single glob expressionIf you want to check for the existence of multiple paths, you can pass a list instead. You can freely mix literal paths and globs.
- name:pypyr.steps.pathcheckin:pathCheck:- ./file1# literal relative path- .</description></item><item><title>pypyr.steps.jump</title><link>https://pypyr.io/docs/steps/jump/</link><pubDate>Mon, 06 Jul 2020 12:43:39 +0100</pubDate><guid>https://pypyr.io/docs/steps/jump/</guid><description>pypyr.steps.jump permalink jump to another step in pipeline permalinkJump to another step-group. This effectively stops processing on the current step-group from which you are jumping.
If you want to return to the point of origin after the step-group you jumped to completes, use call instead.
input permalinkjump expects a context item jump. It can take one of two forms:
- name:pypyr.steps.jumpcomment:simple string means just call the step-group named &amp;#34;jumphere&amp;#34;in:jump:jumphere- name:pypyr.</description></item><item><title>pypyr.steps.glob</title><link>https://pypyr.io/docs/steps/glob/</link><pubDate>Mon, 06 Jul 2020 12:26:50 +0100</pubDate><guid>https://pypyr.io/docs/steps/glob/</guid><description>pypyr.steps.glob permalink get all matching existing paths from glob permalinkResolve a glob and get all the paths that exist on the filesystem for the input glob.
Any given path can point to a file or a directory.
The glob context key must exist in input context:
- name:pypyr.steps.globin:glob:./**/*.py# single globIf you want to resolve multiple globs simultaneously and combine the results, you can pass a list instead. You can freely mix literal paths and globs.</description></item><item><title>pypyr.steps.filewriteyaml</title><link>https://pypyr.io/docs/steps/filewriteyaml/</link><pubDate>Mon, 06 Jul 2020 12:07:43 +0100</pubDate><guid>https://pypyr.io/docs/steps/filewriteyaml/</guid><description>pypyr.steps.filewriteyaml permalink create yaml file from any context object permalinkFormat &amp;amp; write a payload to a yaml file on disk. This is useful for generating yaml files from your pipeline such as when you want to create configuration files dynamically on the fly.
filewriteyaml works like this:
- name:pypyr.steps.filewriteyamlcomment:write context payload out to yamlin:fileWriteYaml:path:/path/to/output.yaml# destination filepayload:# (optional) payload to write to pathkey1:value1# output yaml will havekey2:value2# key1 and key2 as string.</description></item><item><title>pypyr.steps.filewritejson</title><link>https://pypyr.io/docs/steps/filewritejson/</link><pubDate>Mon, 06 Jul 2020 11:38:51 +0100</pubDate><guid>https://pypyr.io/docs/steps/filewritejson/</guid><description>pypyr.steps.filewritejson permalink create json file from any context object permalinkFormat &amp;amp; write a payload to a json file on disk. This is useful for generating json files from your pipeline such as when you want to create configuration files dynamically on the fly.
filewritejson works like this:
- name:pypyr.steps.filewritejsoncomment:write context payload out to jsonin:fileWriteJson:path:/path/to/output.json# destination filepayload:# (optional) payload to write to pathkey1:value1# output json will havekey2:value2# key1 and key2 as stringkey3:124# output intkey4:false# output boolThis will generate the following json to /path/to/output.</description></item><item><title>pypyr.steps.filereplace</title><link>https://pypyr.io/docs/steps/filereplace/</link><pubDate>Fri, 03 Jul 2020 18:00:13 +0100</pubDate><guid>https://pypyr.io/docs/steps/filereplace/</guid><description>pypyr.steps.filereplace permalink find &amp;amp; replace arbitrary strings in a file permalinkParses input text file and replaces any given search strings.
The other fileformat steps, by way of contradistinction, uses string formatting expressions inside {braces} to format values against the pypyr context.
This step, however, lets you find any arbitrary search string and replace it with any replacement string. This is especially handy if you are working with a file where curly braces aren&amp;rsquo;t helpful for a formatting expression - e.</description></item><item><title>pypyr.steps.fileformatyaml</title><link>https://pypyr.io/docs/steps/fileformatyaml/</link><pubDate>Thu, 02 Jul 2020 17:23:36 +0100</pubDate><guid>https://pypyr.io/docs/steps/fileformatyaml/</guid><description>pypyr.steps.fileformatyaml permalink find &amp;amp; replace tokens in yaml file permalinkParses input yaml file and substitutes {tokens} from the pypyr context.
Pretty much does the same thing as pypyr.steps.fileformat, only it makes it easier to work with curly braces for substitutions without tripping over the yaml&amp;rsquo;s structural braces.
If your yaml doesn&amp;rsquo;t use curly braces that aren&amp;rsquo;t meant for {token} substitutions, you can happily use pypyr.steps.fileformat instead - it&amp;rsquo;s more memory efficient.</description></item><item><title>pypyr.steps.fileformatjson</title><link>https://pypyr.io/docs/steps/fileformatjson/</link><pubDate>Thu, 02 Jul 2020 17:23:30 +0100</pubDate><guid>https://pypyr.io/docs/steps/fileformatjson/</guid><description>pypyr.steps.fileformatjson permalink find &amp;amp; replace tokens in json permalinkParses input json file and substitutes {tokens} from the pypyr context.
Pretty much does the same thing as pypyr.steps.fileformat, only it makes it easier to work with curly braces for substitutions without tripping over the json&amp;rsquo;s structural braces.
Given input json like this:
{ &amp;#34;k1&amp;#34;: &amp;#34;v1&amp;#34;, &amp;#34;k2&amp;#34;: { &amp;#34;k2.1&amp;#34;: &amp;#34;v2.1&amp;#34;, &amp;#34;k2.2&amp;#34;: [ &amp;#34;2.2.1&amp;#34;, &amp;#34;START {replaceMeNested} END&amp;#34; ] }, &amp;#34;k3&amp;#34;: &amp;#34;{replaceMeString}&amp;#34;, &amp;#34;k4&amp;#34;: &amp;#34;{replaceMeInt}&amp;#34;, &amp;#34;k5&amp;#34;: &amp;#34;{replaceMeBool}&amp;#34;, &amp;#34;{replaceMeKey}&amp;#34;: &amp;#34;this will replace the key&amp;#34; } And a pipeline like this:</description></item><item><title>pypyr.steps.fileformat</title><link>https://pypyr.io/docs/steps/fileformat/</link><pubDate>Wed, 01 Jul 2020 20:17:37 +0100</pubDate><guid>https://pypyr.io/docs/steps/fileformat/</guid><description>pypyr.steps.fileformat permalink find &amp;amp; replace tokens in text files permalinkParses input text file, substitutes {tokens} in the text of the file from the pypyr context and writes the result to an output file.
- name:pypyr.steps.fileformatcomment:read a file from disk,do some substitutions,write back to disk.in:fileFormat:in:./in/arb.txt# requiredout:./out/arb.txt# optionalSo if you had a text file like this:
{k1} sit thee down and write In a book that all may {k2} And your pypyr context were:</description></item><item><title>pypyr.steps.fetchyaml</title><link>https://pypyr.io/docs/steps/fetchyaml/</link><pubDate>Wed, 01 Jul 2020 20:02:35 +0100</pubDate><guid>https://pypyr.io/docs/steps/fetchyaml/</guid><description>pypyr.steps.fetchyaml permalink load &amp;amp; parse yaml permalinkLoads a yaml file into the pypyr context.
This step requires the following key in the pypyr context:
- name:pypyr.steps.fetchyamldescription:fetch yaml from pathin:fetchYaml:path:./path.yaml# required. path to file on disk. can be relative.key:destinationKey# optional. write yaml to this context key.If you do not specify key, yaml writes directly to context root.
If you do not want to specify a key, you can also use the streamlined format:</description></item><item><title>pypyr.steps.fetchjson</title><link>https://pypyr.io/docs/steps/fetchjson/</link><pubDate>Wed, 01 Jul 2020 19:02:21 +0100</pubDate><guid>https://pypyr.io/docs/steps/fetchjson/</guid><description>pypyr.steps.fetchjson permalink load &amp;amp; parse json permalinkLoads a json file into the pypyr context.
This step requires the following key in the pypyr context:
- name:pypyr.steps.fetchjsoncomment:fetch json from pathin:fetchJson:path:./path.json# required. path to file on disk. can be relative.key:destinationKey# optional. write json to this context key.If you do not specify key, json writes directly to context root.
If you do not want to specify a key, you can also use the streamlined format:</description></item><item><title>pypyr.steps.envget</title><link>https://pypyr.io/docs/steps/envget/</link><pubDate>Wed, 01 Jul 2020 17:19:44 +0100</pubDate><guid>https://pypyr.io/docs/steps/envget/</guid><description>pypyr.steps.envget permalink get environment variables into context permalinkGet environment variables, and assign an optional default value to context if the sought environment variables do not exist.
The difference between pypyr.steps.envget and pypyr.steps.env , is that pypyr.steps.envget won&amp;rsquo;t raise an error if the $ENV doesn&amp;rsquo;t exist.
The envget context key must exist.
All inputs support substitutions.
See a worked example for getting environment variables with defaults here.
get an environment variable with a default fallback permalink- name:pypyr.</description></item><item><title>pypyr.steps.env</title><link>https://pypyr.io/docs/steps/env/</link><pubDate>Wed, 01 Jul 2020 17:11:02 +0100</pubDate><guid>https://pypyr.io/docs/steps/env/</guid><description>pypyr.steps.env permalink use environment variables in your pipeline permalinkGet, set or unset environment variables.
The env context key must exist. env can contain a combination of get, set and unset keys. You must specify at least one of get, set and unset.
env:get:contextkey1:env1contextkey2:env2set:env1:value1env2:value2unset:- env1- env2This step will run whatever combination of Get, Set and Unset you specify. Regardless of combination, execution order is:
get set unset - name:pypyr.</description></item><item><title>pypyr.steps.default</title><link>https://pypyr.io/docs/steps/default/</link><pubDate>Wed, 01 Jul 2020 12:22:55 +0100</pubDate><guid>https://pypyr.io/docs/steps/default/</guid><description>pypyr.steps.default permalink initialize the context with default values permalinkSets values in context if they do not exist already. Does not overwrite existing values. Supports nested hierarchies.
This is especially useful for setting default values in context, for example when using optional arguments from the cli.
This step sets the contents of the context key defaults into context where keys in defaults do not exist in context already. The contents of the defaults key must be a dictionary.</description></item><item><title>pypyr.steps.debug</title><link>https://pypyr.io/docs/steps/debug/</link><pubDate>Wed, 01 Jul 2020 12:03:17 +0100</pubDate><guid>https://pypyr.io/docs/steps/debug/</guid><description>pypyr.steps.debug permalink debug the context permalinkPretty print the context to output.
Print the pypyr context to the pypyr output. This is likely to be the console. This may assist in debugging when trying to see what values are what.
debug prints to the INFO (20) log-level. This means you won&amp;rsquo;t see debug output unless you specify pypyr mypype --log 20 or lower value for log. If you have values you that always want to print to output, echo is the more natural step to use.</description></item><item><title>pypyr.steps.contextsetf</title><link>https://pypyr.io/docs/steps/contextsetf/</link><pubDate>Tue, 30 Jun 2020 20:28:46 +0100</pubDate><guid>https://pypyr.io/docs/steps/contextsetf/</guid><description>pypyr.steps.contextsetf permalink set context values with formatting &amp;amp; dynamic expressions permalinkSet context keys with arbitrary values of different types. You can also use formatting expressions for assigning dynamic run-time values, using substitutions.
This is roughly the equivalent of instantiating and assigning a variable in traditional programming.
Requires the contextSetf key in context. contextSetf is a dictionary of items to set in context. For example, here is how you can set arbitrary values with different types to arbitrary keys:</description></item><item><title>pypyr.steps.contextmerge</title><link>https://pypyr.io/docs/steps/contextmerge/</link><pubDate>Tue, 30 Jun 2020 19:51:26 +0100</pubDate><guid>https://pypyr.io/docs/steps/contextmerge/</guid><description>pypyr.steps.contextmerge permalink merging context values permalinkMerges values into context, preserving the existing hierarchy while only updating the differing values as specified in the contextMerge input.
By comparison, contextcopy and contextsetf overwrite the destination hierarchy that is in context already.
This step merges the contents of the context key contextMerge into context. The contents of the contextMerge key must be a dictionary.
examples permalinkFor example, say input context is:
key1:value1key2:value2key3:k31:value31k32:value32contextMerge:key2:&amp;#39;aaa_{key1}_zzz&amp;#39;key3:k33:value33_{key1}key4:&amp;#39;bbb_{key2}_yyy&amp;#39;This will result in return context:</description></item><item><title>pypyr.steps.contextclearall</title><link>https://pypyr.io/docs/steps/contextclearall/</link><pubDate>Tue, 30 Jun 2020 19:04:00 +0100</pubDate><guid>https://pypyr.io/docs/steps/contextclearall/</guid><description>pypyr.steps.contextclearall permalinkWipe the entire context. No input context arguments required.
You can always use contextclearall as a simple step, since it does not require any input context.
Sample pipeline yaml:
steps:- my.arb.step- pypyr.steps.contextclearall- another.arb.stepcontextclearall also wipes all the imports from any preceding pyimport steps.</description></item><item><title>pypyr.steps.contextclear</title><link>https://pypyr.io/docs/steps/contextclear/</link><pubDate>Tue, 30 Jun 2020 19:03:21 +0100</pubDate><guid>https://pypyr.io/docs/steps/contextclear/</guid><description>pypyr.steps.contextclear permalinkRemove the specified items from the context.
Will iterate contextClear and remove those keys from context.
steps:- name:pypyr.steps.contextcleardescription:delete these 2 context keysin:contextClear:- removeMe- removeMeTooFor example, say input context is:
key1:value1key2:value2key3:value3key4:value4contextClear:- key2- key4- contextClearThis will result in return context:
key1:value1key3:value3Notice how contextClear also cleared itself in this example.</description></item><item><title>pypyr.steps.cmd</title><link>https://pypyr.io/docs/steps/cmd/</link><pubDate>Sat, 13 Jun 2020 21:38:57 +0100</pubDate><guid>https://pypyr.io/docs/steps/cmd/</guid><description>pypyr.steps.cmd permalink execute arbitrary external commands, applications &amp;amp; scripts permalinkRun a program, run an external script, application or command. Execute the context value cmd as a sub-process.
In cmd, you cannot use things like exit, return, shell pipes, filename wildcards, environment variable expansion, and expansion of ~ to a user&amp;rsquo;s home directory. Use pypyr.steps.shell for this instead. cmd runs a command, it does not invoke the shell.
set command input permalinkInput context can take one of two forms:</description></item><item><title>format string interpolation</title><link>https://pypyr.io/docs/substitutions/format-string/</link><pubDate>Sat, 13 Jun 2020 21:38:57 +0100</pubDate><guid>https://pypyr.io/docs/substitutions/format-string/</guid><description>string interpolation permalink formatting expressions with replacement tokens permalinkYou can use substitution tokens, aka string interpolation, to format strings where specified for context items. This substitutes anything between {curly braces} with the context value for that key. This also works with nested values where you have dictionaries/lists inside dictionaries/lists.
For example, if your context looked like this:
key1:downkey2:valleyskey3:value3key4:Piping {key1} the {key2} wild# key4 == &amp;#39;Piping down the valleys wild&amp;#39; nested values permalinkYou can reference keys nested deeper in the context hierarchy, in cases where you have a dictionary that contains lists/dictionaries that might contain other lists/dictionaries and so forth.</description></item><item><title>jsonify</title><link>https://pypyr.io/docs/substitutions/jsonify/</link><pubDate>Sat, 13 Jun 2020 21:38:57 +0100</pubDate><guid>https://pypyr.io/docs/substitutions/jsonify/</guid><description>jsonify permalink convert object to json string permalinkUse jsonify to serialize a pypyr context object to a json string.
- name:pypyr.steps.contextsetfin:contextSetf:myJsonDict:!jsonifyk1:v1k2:123k3:Falsek4:- 1- 2- a:bc:dmyJsonList:!jsonify- zero- one- twomyJsonNull:!jsonify nullmyJsonNumber:!jsonify 99myJsonQuotedString:!jsonify &amp;#34;0123&amp;#34;myJsonBareString:!jsonify arbitrary string- name:pypyr.steps.echoin:echoMe:|myJsonDict: {myJsonDict} myJsonList: {myJsonList} myJsonNull: {myJsonNull} myJsonNumber: {myJsonNumber} myJsonQuotedString: {myJsonQuotedString} myJsonBareString: {myJsonBareString}This gives output:
myJsonDict: {&amp;#34;k1&amp;#34;: &amp;#34;v1&amp;#34;, &amp;#34;k2&amp;#34;: 123, &amp;#34;k3&amp;#34;: false, &amp;#34;k4&amp;#34;: [1, 2, {&amp;#34;a&amp;#34;: &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;: &amp;#34;d&amp;#34;}]} myJsonList: [&amp;#34;zero&amp;#34;, &amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;] myJsonNull: null myJsonNumber: 99 myJsonQuotedString: &amp;#34;0123&amp;#34; myJsonBareString: &amp;#34;arbitrary string&amp;#34; You could think of this as converting yaml to json, however, in actuality under the hood pypyr will serialize any given object in context to json with jsonify so it&amp;rsquo;s not necessarily just yaml as the input.</description></item><item><title>py string - dynamic python expressions</title><link>https://pypyr.io/docs/substitutions/py-strings/</link><pubDate>Sat, 13 Jun 2020 21:38:57 +0100</pubDate><guid>https://pypyr.io/docs/substitutions/py-strings/</guid><description>py strings permalink dynamic python expressions permalinkpy strings allow you to execute python expressions dynamically. This lets you use a python expression wherever you can use a string formatting expression.
A py string looks like this:
!py &amp;lt;&amp;lt;your python expression here&amp;gt;&amp;gt; Context keys exist as variables of the same name.
For example, if context['key'] is &amp;lsquo;abc&amp;rsquo;, the following will return True: !py len(key) == 3&amp;quot;
Notice that you can use the context keys directly as variables.</description></item><item><title>sic string - literal strings</title><link>https://pypyr.io/docs/substitutions/sic-strings/</link><pubDate>Sat, 13 Jun 2020 21:38:57 +0100</pubDate><guid>https://pypyr.io/docs/substitutions/sic-strings/</guid><description>sic strings permalink literal string values permalinkIf a string is NOT to have {substitutions} run on it, it&amp;rsquo;s sic erat scriptum, or sic for short. This is handy especially when you are dealing with json as a string, rather than an actual json object, so you don&amp;rsquo;t have to use escape sequences to double curly all the structural braces and it simplifies the need for escape sequences.
A sic string looks like this:</description></item><item><title>release v3.2.1</title><link>https://pypyr.io/updates/releases/v3.2.1/</link><pubDate>Tue, 14 Apr 2020 02:20:27 +0000</pubDate><guid>https://pypyr.io/updates/releases/v3.2.1/</guid><description>pypyr release v3.2.1 permalink Support non-string keys in context on Formatting &amp;amp; Merge permalinkRelease Date: 2020-04-14T02:20:27Z
Allow non-string keys on context.get_formatted_iterable and context merge (including the step pypyr.steps.contextmerge). Resolves #179. Much thanks to @Reskov for a detailed &amp;amp; helpful bug report! You can find pypyr release v3.2.1 on github, where you can click through to associated Issues, Pull Requests and Users.
Released by yaythomas.</description></item><item><title>release v3.2.0</title><link>https://pypyr.io/updates/releases/v3.2.0/</link><pubDate>Sat, 04 Apr 2020 13:33:40 +0000</pubDate><guid>https://pypyr.io/updates/releases/v3.2.0/</guid><description>pypyr release v3.2.0 permalink nested call inside loops &amp;amp; in context clearing preview permalinkRelease Date: 2020-04-04T13:33:40Z
ATTENTION: Please start preparing all your pipelines to be ready for the next major release where in context arguments will be removed from context on step completion. This shouldn&amp;rsquo;t be too much of an issue. For any steps where you need to set enduring context, use contextsetf or contextset.
Allow using a call control-of-flow instruction nested inside while/for/retry loops.</description></item><item><title>release v3.1.0</title><link>https://pypyr.io/updates/releases/v3.1.0/</link><pubDate>Tue, 11 Feb 2020 19:24:11 +0000</pubDate><guid>https://pypyr.io/updates/releases/v3.1.0/</guid><description>pypyr release v3.1.0 permalink API change to main entrypoint for logging permalinkRelease Date: 2020-02-11T19:24:11Z
pypyr.log.logger.set_root_logger(log_level, log_path) call moved from pipelinerunner.main() to cli.main()
this has the side-effect that pipelinerunner.main() signature has changed, with log_level and log_path removed. API consumers should update.
Reason being API consumers should set their own log handlers, since handler configuration should be the prerogative of the calling application, not the invoked library.
Re #172, #173
You can find pypyr release v3.</description></item><item><title>release v3.0.3</title><link>https://pypyr.io/updates/releases/v3.0.3/</link><pubDate>Wed, 29 Jan 2020 01:03:12 +0000</pubDate><guid>https://pypyr.io/updates/releases/v3.0.3/</guid><description>pypyr release v3.0.3 permalink Retry Decorator handles original errors when calling Groups permalinkRelease Date: 2020-01-29T01:03:12Z
Retry Decorator correctly handles errors raised from .call or .jump steps when checking error type with retryOn and stopOn. Close #170 - thanks to @Reskov for reporting! add tarball to PyPI deploy artefacts. You can find pypyr release v3.0.3 on github, where you can click through to associated Issues, Pull Requests and Users.</description></item><item><title>release v3.0.2</title><link>https://pypyr.io/updates/releases/v3.0.2/</link><pubDate>Mon, 18 Nov 2019 19:30:27 +0000</pubDate><guid>https://pypyr.io/updates/releases/v3.0.2/</guid><description>pypyr release v3.0.2 permalink Better error messages on failing import modules permalinkRelease Date: 2019-11-18T19:30:27Z
When importing a step that does exist (mystep.blah), a failing import mymodule.blah inside mystep.blah would give a misleading error and hide the actual source of the problem. Fixes #166. Eternal thanks to @irancati for raising the issue! You can find pypyr release v3.0.2 on github, where you can click through to associated Issues, Pull Requests and Users.</description></item><item><title>release v3.0.1</title><link>https://pypyr.io/updates/releases/v3.0.1/</link><pubDate>Fri, 13 Sep 2019 20:11:13 +0000</pubDate><guid>https://pypyr.io/updates/releases/v3.0.1/</guid><description>pypyr release v3.0.1 permalink pypyr.steps.debug &amp;amp; context merge support all types permalinkRelease Date: 2019-09-13T20:11:13Z
With a million thank yous ðŸ™ to @Reskov for these much needed fixes/enhancements! ðŸŽ†
Resolves issue #149. pypyr.steps.debug now supports outputting any type, including PyString &amp;amp; SicString Resolve pypyr.steps.contextmerge issue to support merging any type, including PyString &amp;amp; SicString. You can find pypyr release v3.0.1 on github, where you can click through to associated Issues, Pull Requests and Users.</description></item><item><title>release v3.0.0</title><link>https://pypyr.io/updates/releases/v3.0.0/</link><pubDate>Thu, 22 Aug 2019 17:47:35 +0000</pubDate><guid>https://pypyr.io/updates/releases/v3.0.0/</guid><description>pypyr release v3.0.0 permalink Major version, with BREAKING CHANGES: features custom step groups, caching &amp;amp; no more ./pipelines dir permalinkRelease Date: 2019-08-22T17:47:35Z
BREAKING CHANGE: Remove deprecated step input context for (ref #118) assert env fetchjson fetchyaml fileformat fileformatjson fileformatyaml filereplace tar BREAKING CHANGE: cli context input now uses standard cli spacing rather than needing to str close everything. Closes #94 So where you had: pypyr mypipeline &amp;quot;key1=value1,key2=value2â€ Now instead: pypyr mypipeline key1=value1 key2=value2 BREAKING CHANGE: Big API changes to pipelinerunner, stepsrunner and Step BREAKING CHANGE: pypyr.</description></item><item><title>release v2.11.0</title><link>https://pypyr.io/updates/releases/v2.11.0/</link><pubDate>Tue, 06 Aug 2019 21:16:03 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.11.0/</guid><description>pypyr release v2.11.0 permalink less confusing logging with NOTIFY permalinkRelease Date: 2019-08-06T21:16:03Z
This one is all @Reskov ðŸŽ‰ eternal gratitude!
new NOTIFY logging level added. this level is much less verbose than even INFO, and only displays explicits echos that you specify in your pipeline, and also the description from the step decorator. This should make it much easier to see what your pipeline is doing without the extra detail that can make things confusing and harder to follow.</description></item><item><title>release v2.10.0</title><link>https://pypyr.io/updates/releases/v2.10.0/</link><pubDate>Wed, 10 Jul 2019 08:48:32 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.10.0/</guid><description>pypyr release v2.10.0 permalink Better Errors - line numbers, save errors permalinkRelease Date: 2019-07-10T08:48:32Z
With eternal thanks to @Reskov ðŸŽ‰ for next level super useful improved error handling! ðŸ™‡
#139 - pypyr now saves all run-time errors to context under runErrors. This means subsequent steps can use error information from previous steps. #135 - error information now include the pipeline source yaml line+col numbers You can find pypyr release v2.</description></item><item><title>release v2.9.0</title><link>https://pypyr.io/updates/releases/v2.9.0/</link><pubDate>Fri, 14 Jun 2019 18:51:28 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.9.0/</guid><description>pypyr release v2.9.0 permalink glob step and special tag merge permalinkRelease Date: 2019-06-14T18:51:28Z
pypyr.steps.glob lets you get a list of paths from a glob, and combine different globs into a combined output result list. Issue #145 with much thanks to @Reskov ðŸŽ‰ , resolves issue #143 - merge step now supports special tag directives You can find pypyr release v2.9.0 on github, where you can click through to associated Issues, Pull Requests and Users.</description></item><item><title>release v2.8.0</title><link>https://pypyr.io/updates/releases/v2.8.0/</link><pubDate>Sun, 24 Mar 2019 01:22:01 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.8.0/</guid><description>pypyr release v2.8.0 permalink Retry Decorator and until-style While Loops permalinkRelease Date: 2019-03-24T01:22:01Z
new Retry decorator allows steps to retry automatically when step encounters an error. ref #130 fix run_step AttributeError might have caught or hidden AttributeErrors in the step code itself, rather than just when the step module didn&amp;rsquo;t contain a run_step function. ref #129 while loop checks stop condition only at end of each iteration. previously if a stop condition evaluated True even before the loop started the loop wouldn&amp;rsquo;t run at all.</description></item><item><title>release v2.7.0</title><link>https://pypyr.io/updates/releases/v2.7.0/</link><pubDate>Thu, 21 Mar 2019 15:09:21 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.7.0/</guid><description>pypyr release v2.7.0 permalink pypyr.steps.pype inputs now support string interpolation permalinkRelease Date: 2019-03-21T15:09:21Z
add string interpolation to pypyr.steps.pype input. You can find pypyr release v2.7.0 on github, where you can click through to associated Issues, Pull Requests and Users.
Released by yaythomas.</description></item><item><title>release v2.6.0</title><link>https://pypyr.io/updates/releases/v2.6.0/</link><pubDate>Fri, 08 Feb 2019 16:20:23 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.6.0/</guid><description>pypyr release v2.6.0 permalink pypyr.steps.now and pypyr.steps.nowutc permalinkRelease Date: 2019-02-08T16:20:23Z
get the current datetime stamp into the pypyr context as a formattable string, where you can specify your own datetime formats using the standard python date time replacement tokens like %Y-%m-%d for YYYY-MM-DD. You can find pypyr release v2.6.0 on github, where you can click through to associated Issues, Pull Requests and Users.
Released by yaythomas.</description></item><item><title>release v2.5.0</title><link>https://pypyr.io/updates/releases/v2.5.0/</link><pubDate>Wed, 30 Jan 2019 19:08:54 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.5.0/</guid><description>pypyr release v2.5.0 permalink change the current working directory for cmd and shell permalinkRelease Date: 2019-01-30T19:08:54Z
use the new cwd input on pypyr.steps.cmd and pypyr.steps.shell to set the current working directory for the program/shell that you want to execute. Supports relative paths.
You can find pypyr release v2.5.0 on github, where you can click through to associated Issues, Pull Requests and Users.
Released by yaythomas.</description></item><item><title>release v2.4.0</title><link>https://pypyr.io/updates/releases/v2.4.0/</link><pubDate>Thu, 24 Jan 2019 23:04:20 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.4.0/</guid><description>pypyr release v2.4.0 permalink pypyr.steps.pathcheck &amp;amp; deprecation of old style fetchjson/fetchyaml args permalinkRelease Date: 2019-01-24T23:04:20Z
The new pypyr.steps.pathcheck step allows you see if a path exists on the filesystem. It supports literal paths and glob expansions. It writes handy values into pathCheckOutwith bool for existence and count of files found for the given path. #114 deprecate old style multi context inputs for fetchjson and fetchyaml, #118. this is not just arbitrary: reason is when step is used multiple times in same pipeline, it becomes easy to have left-over values from previous step run left in context that then cause surprising behaviour with the downstream step.</description></item><item><title>release v2.3.0</title><link>https://pypyr.io/updates/releases/v2.3.0/</link><pubDate>Thu, 24 Jan 2019 02:18:47 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.3.0/</guid><description>pypyr release v2.3.0 permalink pypyr.steps.getenv permalinkRelease Date: 2019-01-24T02:18:47Z
add new step pypyr.steps.getenv Whereas pypyr.steps.env raises an error if you are getting an environment variable that doesn&amp;rsquo;t exist, the new envget allows you to specify a default value to use instead. ref #111 some documentation updates to demonstrate how to use py strings for ternary assignments built-in pypes use comment rather than description where output is not meant for operator consumption ref #109 alias the --loglevel switch with --log, so you can now do pypyr mypipe --log 10 think of the savings just on keyboard wear and tear!</description></item><item><title>release v2.2.0</title><link>https://pypyr.io/updates/releases/v2.2.0/</link><pubDate>Fri, 18 Jan 2019 10:34:45 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.2.0/</guid><description>pypyr release v2.2.0 permalink Dynamic pype loading and KeyNotInContextError == KeyError permalinkRelease Date: 2019-01-18T10:34:45Z
This release is all @Reskov! ðŸŽ‰ Much thanks for your excellent contributions to some tricky bits of the pypyr core!
Context KeyNotInContextError now also derives from KeyError. This makes it easier to catch missing key exceptions in scenarios where Context keys contain other dicts. Allow dynamic loading of pipeline loaders. This allows core extensibility to load pipelines differently and from other places than the default file loader.</description></item><item><title>release v2.1.1</title><link>https://pypyr.io/updates/releases/v2.1.1/</link><pubDate>Fri, 04 Jan 2019 11:32:19 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.1.1/</guid><description>pypyr release v2.1.1 permalink Write step description to logger INFO on step execution permalinkRelease Date: 2019-01-04T11:32:19Z
write step description to INFO output on step execution, if it exists. this should help with debugging. minor bug fix: legacy support for envs, recreate env key on legacy key found You can find pypyr release v2.1.1 on github, where you can click through to associated Issues, Pull Requests and Users.</description></item><item><title>release v2.1.0</title><link>https://pypyr.io/updates/releases/v2.1.0/</link><pubDate>Thu, 03 Jan 2019 00:55:09 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.1.0/</guid><description>pypyr release v2.1.0 permalink globs, save cmd out, backwards compatible context change for multi-key steps permalinkRelease Date: 2019-01-03T00:55:09Z
ATTENTION, FUTURE WARNING: all built-in steps that used to take multiple input keys now instead take a dict input. This makes life significantly easier if you re-run the step in the same pipeline in that you don&amp;rsquo;t have to clear down context before the subsequent step runs anymore. The old-style is now deprecated - for the moment pypyr will make the old-style work seamlessly for you by creating the new keys under the hood for you and raising a warning without stopping, but be aware legacy support will be removed on the next major release.</description></item><item><title>release v2.0.0</title><link>https://pypyr.io/updates/releases/v2.0.0/</link><pubDate>Sun, 16 Dec 2018 20:19:49 +0000</pubDate><guid>https://pypyr.io/updates/releases/v2.0.0/</guid><description>pypyr release v2.0.0 permalink Sic Strings, Py Strings, Fetch into Key and file write yaml/json permalinkRelease Date: 2018-12-16T20:19:49Z
pypyr v2.0.0 release! BREAKING CHANGES: [sic] strings are now a lot better. Instead of relying on string-parsing on &amp;ldquo;[sic]&amp;rdquo; and the tricky use of quotes and double-quotes, now a structural yam tag identifies sic string, making it a whole lot simpler to write sic strings with special characters in them without escape sequences or having to deal with {blah} style eye-bleeding messes.</description></item><item><title>release v1.2.1</title><link>https://pypyr.io/updates/releases/v1.2.1/</link><pubDate>Mon, 05 Nov 2018 11:07:17 +0000</pubDate><guid>https://pypyr.io/updates/releases/v1.2.1/</guid><description>pypyr release v1.2.1 permalink no functional change: fix pype bug permalinkRelease Date: 2018-11-05T11:07:17Z
regression problem with pypyr.steps.pype from previous release fixed no functional change You can find pypyr release v1.2.1 on github, where you can click through to associated Issues, Pull Requests and Users.
Released by yaythomas.</description></item><item><title>release v1.2.0</title><link>https://pypyr.io/updates/releases/v1.2.0/</link><pubDate>Mon, 05 Nov 2018 09:26:15 +0000</pubDate><guid>https://pypyr.io/updates/releases/v1.2.0/</guid><description>pypyr release v1.2.0 permalink no functional change: api update permalinkRelease Date: 2018-11-05T09:26:15Z
improve API call-ability of pypyr by splitting the pipeline loading from running, allowing consumer to manage pipeline cache themselves. With great thanks for the excellent idea and implementation by @Reskov! no functional change introduced with this version You can find pypyr release v1.2.0 on github, where you can click through to associated Issues, Pull Requests and Users.</description></item><item><title>release v1.1.1</title><link>https://pypyr.io/updates/releases/v1.1.1/</link><pubDate>Thu, 18 Oct 2018 22:43:18 +0000</pubDate><guid>https://pypyr.io/updates/releases/v1.1.1/</guid><description>pypyr release v1.1.1 permalink no functional change permalinkRelease Date: 2018-10-18T22:43:18Z
no functional change, only devops deployment update supersedes the v1.1.0 release. note that v1.1.0 is not on pypi because of a deployment issue that 1.1.1 rectifies. You can find pypyr release v1.1.1 on github, where you can click through to associated Issues, Pull Requests and Users.
Released by yaythomas.</description></item><item><title>release v1.1.0</title><link>https://pypyr.io/updates/releases/v1.1.0/</link><pubDate>Thu, 18 Oct 2018 22:01:10 +0000</pubDate><guid>https://pypyr.io/updates/releases/v1.1.0/</guid><description>pypyr release v1.1.0 permalink cli: &amp;ndash;logpath + py 3.7 permalinkRelease Date: 2018-10-18T22:01:10Z
cli option to log to a file path in addition to the console using --logpath. With great thanks to @rickardcronholm! slight BREAKING CHANGE for --loglevel: The previous shortening to pypyr mypipe --log 10 won&amp;rsquo;t work anymore. Use pypyr mypipe --logl 10 if you don&amp;rsquo;t want to type out --loglevel python 3.7 compatibility README help with shell examples You can find pypyr release v1.</description></item><item><title>release v1.0.0</title><link>https://pypyr.io/updates/releases/v1.0.0/</link><pubDate>Thu, 26 Jul 2018 20:17:17 +0000</pubDate><guid>https://pypyr.io/updates/releases/v1.0.0/</guid><description>pypyr release v1.0.0 permalink step decorator: while permalinkRelease Date: 2018-07-26T20:17:17Z
while loop decorator README help with examples for all decorators You can find pypyr release v1.0.0 on github, where you can click through to associated Issues, Pull Requests and Users.
Released by yaythomas.</description></item></channel></rss>